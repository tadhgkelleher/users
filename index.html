<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale: 1.0">
    <title>Bubble Shooter VR</title>
    <script src="./three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px 0;
            cursor: pointer;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button id="enterVRButton">Enter VR</button>
        <p id="instructions">Shoot bubbles to match colors and clear them.</p>
        <p id="score">Score: 0</p>
    </div>

    <script>
        // Constants
        const BUBBLE_RADIUS = 0.5;
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 10;
        const COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];  // Red, Green, Blue, Yellow
        const SHOT_SPEED = 10;
        const ROW_OFFSET = BUBBLE_RADIUS * Math.sqrt(3);  // Offset for hexagonal grid

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Score
        let score = 0;
        const scoreElement = document.getElementById('score');

        // Bubble Grid
        const bubbleGrid = [];

        function createBubble(x, y, color) {
            const geometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const bubble = new THREE.Mesh(geometry, material);

            bubble.position.x = x;
            bubble.position.y = y;
            bubble.position.z = -10; // Keep bubbles a bit away from the camera
            bubble.userData.color = color;
            return bubble;
        }

        function populateGrid() {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                bubbleGrid[row] = [];
                for (let col = 0; col < GRID_WIDTH; col++) {
                    // Hexagonal Grid Layout
                    const x = col * 2 * BUBBLE_RADIUS + (row % 2) * BUBBLE_RADIUS;
                    const y = row * ROW_OFFSET;

                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    const bubble = createBubble(x - (GRID_WIDTH * BUBBLE_RADIUS), y - (GRID_HEIGHT * ROW_OFFSET / 2), color); // Centered
                    scene.add(bubble);
                    bubbleGrid[row][col] = bubble;
                }
            }
        }
        populateGrid();

        // Shooting Bubble
        let shootingBubble = null;  // The bubble being shot
        let shotDirection = new THREE.Vector3(0, 0, 0);  // Direction of the shot

        function createShootingBubble() {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            const bubble = createBubble(0, -5, color); // Positioned at the bottom
            scene.add(bubble);
            return bubble;
        }

        function resetShootingBubble() {
            if (shootingBubble) {
                scene.remove(shootingBubble);
            }
            shootingBubble = createShootingBubble();
        }
        resetShootingBubble();


        function launchBubble(direction) {
            if (shootingBubble) {
                shotDirection.copy(direction).normalize(); // Normalize to avoid changing speed
                shootingBubble.userData.isShooting = true;
            }
        }

        // VR Controller setup
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            scene.add(controller2);

            const controllerModelFactory = new THREE.XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // Visualize controller direction
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(geometry);
            line.scale.z = 10;
            controller1.add(line.clone());
            controller2.add(line.clone());
        }

        function onSelectStart(event) {
            const controller = event.target;

            // Get the controller's direction
            const direction = new THREE.Vector3();
            controller.getWorldDirection(direction);

            launchBubble(direction);  // Launch in the controller's direction
        }

        // Collision Detection
        function checkCollision(bubble) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const existingBubble = bubbleGrid[row][col];
                    if (existingBubble) {
                        const distance = bubble.position.distanceTo(existingBubble.position);
                        if (distance < 2 * BUBBLE_RADIUS) {
                            return { row: row, col: col };  // Return collision location
                        }
                    }
                }
            }
            return null;
        }

        function placeBubble(bubble, collision) {
            if (collision) {
                // Find an empty spot adjacent to the collision point
                let newRow = collision.row;
                let newCol = collision.col;

                //Basic logic. Needs refinement
                if (bubbleGrid[newRow][newCol -1 ] == null) {
                  newCol = newCol -1;
                }
                else if (bubbleGrid[newRow][newCol +1 ] == null) {
                  newCol = newCol +1;
                }

                bubble.position.copy(bubbleGrid[collision.row][collision.col].position);
                bubble.position.z = -10; // Correct z position
                bubbleGrid[newRow][newCol] = bubble;

                const x = newCol * 2 * BUBBLE_RADIUS + (newRow % 2) * BUBBLE_RADIUS;
                const y = newRow * ROW_OFFSET;
                bubble.position.x = x - (GRID_WIDTH * BUBBLE_RADIUS);
                bubble.position.y = y - (GRID_HEIGHT * ROW_OFFSET / 2);

                bubble.userData.isShooting = false;
                shootingBubble = null;
                resetShootingBubble();
                return {row:newRow, col:newCol}
            }
            return null;
        }


        function checkMatches(startRow, startCol) {
            const startBubble = bubbleGrid[startRow][startCol];
            if (!startBubble) return [];

            const matchedBubbles = [];
            const visited = {};
            const color = startBubble.userData.color;

            function explore(row, col) {
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) return;
                if (visited[row + ',' + col]) return;

                const bubble = bubbleGrid[row][col];
                if (!bubble || bubble.userData.color !== color) return;

                visited[row + ',' + col] = true;
                matchedBubbles.push(bubble);

                explore(row + 1, col);
                explore(row - 1, col);
                explore(row, col + 1);
                explore(row, col - 1);

                // Adjust for Hexagonal Grid
                if (row % 2 === 0) {
                    explore(row - 1, col - 1);
                    explore(row + 1, col - 1);
                } else {
                    explore(row - 1, col + 1);
                    explore(row + 1, col + 1);
                }
            }

            explore(startRow, startCol);
            return matchedBubbles;
        }

        function removeMatches(matches) {
            if (matches.length >= 3) {
                matches.forEach(bubble => {
                    for (let row = 0; row < GRID_HEIGHT; row++) {
                        for (let col = 0; col < GRID_WIDTH; col++) {
                            if (bubbleGrid[row][col] === bubble) {
                                scene.remove(bubble);
                                bubbleGrid[row][col] = null;
                                score += 10; // Increase score
                                scoreElement.textContent = 'Score: ' + score;
                            }
                        }
                    }
                });
            }
        }

        // VR and Non-VR mode
        camera.position.set(0, 0, 0);

        // VR Support check
        let vrButton = document.getElementById('enterVRButton');
        let statusText = document.getElementById('status');  // Make sure you have a status display in your HTML

        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                vrButton.disabled = !supported;
                vrButton.textContent = supported ? 'Enter VR' : 'VR not supported';
            });
        }
        else {
            vrButton.disabled = true;
            vrButton.textContent = 'VR not supported';
        }

        vrButton.addEventListener('click', function() {

            if (renderer.xr.isPresenting) {
                renderer.xr.getSession().end();
                vrButton.textContent = 'Enter VR';
            } else {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                }).then(function(session) {
                    renderer.xr.setSession(session);
                    vrButton.textContent = 'Exit VR';
                    setupVRControllers();
                }).catch(function(error) {
                    console.error("Failed to start VR", error);
                });
            }
        });


        // Animation loop
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (shootingBubble && shootingBubble.userData.isShooting) {
                shootingBubble.position.addScaledVector(shotDirection, SHOT_SPEED / 60);

                const collision = checkCollision(shootingBubble);
                if (collision) {
                    shootingBubble.userData.isShooting = false;

                    let newPos = placeBubble(shootingBubble, collision)
                    if (newPos) {
                      const matches = checkMatches(newPos.row, newPos.col);
                      removeMatches(matches);

                    }
                }
                else if (shootingBubble.position.length() > 50)
                {
                   shootingBubble.userData.isShooting = false;
                   shootingBubble = null;
                   resetShootingBubble();
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle browser resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

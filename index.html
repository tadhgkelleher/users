<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Healing Prototype</title>
    <script src="./three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
        #breathingButton {
            display: none;
            padding: 10px 20px;
            font-size: 16px;
        }
        button, input {
            margin: 5px 0;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- UI -->
    <div id="ui">
        <label for="painLevel">Pain Level (1-10): </label>
        <input type="range" id="painLevel" min="1" max="10" value="5">
        <br>
        <button id="startButton">Start</button>
        <button id="breathingButton">Click with each inhalation</button>
        <p id="instructions">Set your pain level and click Start. Then, click when the sphere starts expanding (every 10s).</p>
        <p id="counterDisplay">Matches: 0</p>
    </div>

    <!-- Three.js Logic -->
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Sphere
        const geometry = new THREE.SphereGeometry(1.25, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(0, 0, -5);
        scene.add(sphere);

        // Background (Sky-like)
        scene.background = new THREE.Color(0x87CEEB);

        // Camera Position
        camera.position.z = 5;

        // Animation Variables
        const period = 10; // 10s cycle
        let windowSize = 1;
        let startTime;
        let counter = 0;
        let isStarted = false;
        let scale = 1;

        // DOM Elements
        const painLevelInput = document.getElementById('painLevel');
        const startButton = document.getElementById('startButton');
        const breathingButton = document.getElementById('breathingButton');
        const counterDisplay = document.getElementById('counterDisplay');

        // Adjust timing window based on pain level
        painLevelInput.addEventListener('input', () => {
            const painLevel = parseInt(painLevelInput.value);
            windowSize = 0.5 + (painLevel - 1) / 9 * 1.5; // 0.5s to 2s
        });

        // Start the experience
        startButton.addEventListener('click', () => {
            startTime = performance.now() / 1000;
            isStarted = true;
            startButton.style.display = 'none';
            breathingButton.style.display = 'block';
        });

        // Handle breathing button clicks
        breathingButton.addEventListener('click', () => {
            if (!isStarted) return;

            const currentTime = performance.now() / 1000;
            const t = currentTime - startTime;
            const closestTarget = Math.round(t / period) * period;
            const diff = Math.abs(t - closestTarget);

            if (diff < windowSize) {
                counter++;
            } else {
                counter = 0;
            }

            counterDisplay.textContent = `Matches: ${counter}`;
            material.color.setHex(counter >= 3 ? 0x00ff00 : 0xff0000); // Green or Red
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            if (isStarted) {
                const elapsed = (performance.now() / 1000) - startTime;
                const phase = (elapsed % period) / period; // 0 to 1 over 10s
                scale = 1 + 0.5 * Math.sin(phase * Math.PI * 2); // 1 to 1.5 and back
                sphere.scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

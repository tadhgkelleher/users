<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Bubble Shooter - Aimed!</title>
    <script src="./three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px 0;
            cursor: pointer;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button id="enterVRButton">Enter VR</button>
        <p id="instructions">Aim with the gun (mouse/VR controller) and shoot!</p>
        <p id="score">Score: 0</p>
        <p id="level">Level: 1</p>
    </div>

    <script>
        // --- Constants ---
        const BUBBLE_RADIUS = 0.5;
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 15;
        const COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff69b4];
        const SHOT_SPEED = 15;
        const ROW_OFFSET = BUBBLE_RADIUS * Math.sqrt(3);
        const POWERUP_CHANCE = 0.05;

        // --- Power-up Types ---
        const POWERUP_TYPES = {
            CLEAR_ROW: "CLEAR_ROW",
            COLOR_BOMB: "COLOR_BOMB",
            SCORE_BOOST: "SCORE_BOOST"
        };

        // --- Game State ---
        let score = 0;
        let level = 1;
        let bubbleGrid = [];
        let shootingBubble = null;
        let shotDirection = new THREE.Vector3(0, 0, 0);
        let aimingGun = null; // The gun object for aiming

        // --- UI Elements ---
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- Aiming Gun ---
        function createAimingGun() {
            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 12); // Cylinder shape
            const material = new THREE.MeshBasicMaterial({ color: 0x888888 }); // Gray color
            const gun = new THREE.Mesh(geometry, material);

            gun.position.set(0, -5, 0);  // Position at the bottom
            gun.rotation.x = Math.PI / 2; // Rotate to point forward

            return gun;
        }

        aimingGun = createAimingGun();
        scene.add(aimingGun);

        // --- Bubble Creation and Grid Management ---
        function createBubble(x, y, color, isPowerup = false) {
            const geometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const bubble = new THREE.Mesh(geometry, material);

            bubble.position.set(x, y, -10);
            bubble.userData = { color: color, isPowerup: isPowerup };
            return bubble;
        }


        function getRandomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        function createRandomBubble(x, y) {
            const isPowerup = Math.random() < POWERUP_CHANCE;
            const color = isPowerup ? 0xffffff : getRandomColor(); // White for Power-ups
            return createBubble(x, y, color, isPowerup);
        }

        function populateGrid() {
            bubbleGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(null));

            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const x = col * 2 * BUBBLE_RADIUS + (row % 2) * BUBBLE_RADIUS;
                    const y = row * ROW_OFFSET;

                    const bubble = createRandomBubble(x - (GRID_WIDTH * BUBBLE_RADIUS), y - (GRID_HEIGHT * ROW_OFFSET / 2));

                    bubbleGrid[row][col] = bubble;
                    scene.add(bubble);
                }
            }
        }

        function resetGrid() {
            bubbleGrid.forEach(row => row.forEach(bubble => {
                if (bubble) scene.remove(bubble);
            }));
            bubbleGrid = [];
            populateGrid();
        }

        // --- Shooting ---
        function createShootingBubble() {
            const isPowerup = Math.random() < POWERUP_CHANCE;
            const color = isPowerup ? 0xffffff : getRandomColor();
            const bubble = createBubble(0, -5, color, isPowerup);
            return bubble;
        }

        function resetShootingBubble() {
            if (shootingBubble) scene.remove(shootingBubble);
            shootingBubble = createShootingBubble();
            scene.add(shootingBubble);
        }

        function launchBubble() {
            if (shootingBubble) {
                shotDirection.set(0,0,-1); //Shoot based on gun direction
                aimingGun.getWorldDirection(shotDirection);
                shotDirection.normalize();
                shootingBubble.userData.isShooting = true;
            }
        }

        // --- Collision and Placement ---
        function checkCollision(bubble) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const existingBubble = bubbleGrid[row][col];
                    if (existingBubble) {
                        const distance = bubble.position.distanceTo(existingBubble.position);
                        if (distance < 2 * BUBBLE_RADIUS) {
                            return { row: row, col: col };
                        }
                    }
                }
            }
            return null;
        }


        function placeBubble(bubble, collision) {
            if (!collision) return null;

            let newRow = collision.row;
            let newCol = collision.col;

            // More sophisticated placement logic
            let placed = false;
            const adjacentPositions = [
                { row: newRow, col: newCol - 1 },
                { row: newRow, col: newCol + 1 },
                { row: newRow - 1, col: newCol + (newRow % 2) },
                { row: newRow - 1, col: newCol - 1 + (newRow % 2) },
                { row: newRow + 1, col: newCol + (newRow % 2) },
                { row: newRow + 1, col: newCol - 1 + (newRow % 2) }
            ];

            for (const pos of adjacentPositions) {
                if (pos.row >= 0 && pos.row < GRID_HEIGHT && pos.col >= 0 && pos.col < GRID_WIDTH && !bubbleGrid[pos.row][pos.col]) {

                    newRow = pos.row;
                    newCol = pos.col;
                    placed = true;
                    break;  // Place in the first available spot
                }
            }

            if (!placed) return null;  // No place to put it!

            // Calculate world position based on grid
            const x = newCol * 2 * BUBBLE_RADIUS + (newRow % 2) * BUBBLE_RADIUS;
            const y = newRow * ROW_OFFSET;

            bubble.position.x = x - (GRID_WIDTH * BUBBLE_RADIUS);
            bubble.position.y = y - (GRID_HEIGHT * ROW_OFFSET / 2);
            bubble.position.z = -10; //Ensure correct z

            bubble.userData.isShooting = false;
            bubbleGrid[newRow][newCol] = bubble;

            return { row: newRow, col: newCol };
        }


        // --- Matching and Power-ups ---
        function checkMatches(startRow, startCol) {
            const startBubble = bubbleGrid[startRow][startCol];
            if (!startBubble || startBubble.userData.isPowerup) return [];

            const matchedBubbles = [];
            const visited = {};
            const color = startBubble.userData.color;

            function explore(row, col) {
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) return;
                if (visited[row + ',' + col]) return;

                const bubble = bubbleGrid[row][col];
                if (!bubble || bubble.userData.isPowerup || bubble.userData.color !== color) return;

                visited[row + ',' + col] = true;
                matchedBubbles.push(bubble);

                explore(row + 1, col);
                explore(row - 1, col);
                explore(row, col + 1);
                explore(row, col - 1);

                if (row % 2 === 0) {
                    explore(row - 1, col - 1);
                    explore(row + 1, col - 1);
                } else {
                    explore(row - 1, col + 1);
                    explore(row + 1, col + 1);
                }
            }

            explore(startRow, startCol);
            return matchedBubbles;
        }

        function removeMatches(matches) {
            if (matches.length >= 3) {
                matches.forEach(bubble => {
                    for (let row = 0; row < GRID_HEIGHT; row++) {
                        for (let col = 0; col < GRID_WIDTH; col++) {
                            if (bubbleGrid[row][col] === bubble) {
                                scene.remove(bubble);
                                bubbleGrid[row][col] = null;
                                increaseScore(10);
                            }
                        }
                    }
                });
            }
        }

        function increaseScore(amount) {
            score += amount;
            scoreElement.textContent = 'Score: ' + score;
        }

        // --- Desktop Controls ---
        document.addEventListener('mousedown', function() {
            launchBubble();
        });

        document.addEventListener('mousemove', (event) => {
            // Calculate mouse position in normalized device coordinates (-1 to +1) for both axes.
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Create a ray from the camera through the mouse position
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Define a plane to intersect with (the aiming plane)
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);  // Plane is at z=0
            const intersectPoint = new THREE.Vector3();

            raycaster.ray.intersectPlane(plane, intersectPoint);

            // Now aim the gun at the intersection point
            if (intersectPoint) {
                aimingGun.lookAt(intersectPoint);
                aimingGun.rotation.x += Math.PI / 2; // Adjust for cylinder orientation
            }
        });

        // --- VR Controller Setup ---
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            scene.add(controller2);

            const controllerModelFactory = new THREE.XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

           // Attach the aiming gun to the controller (controller1 in this case)
           controller1.add(aimingGun);
           aimingGun.position.set(0, -0.2, -0.5); // Adjust position relative to controller
           aimingGun.rotation.set(0, 0, 0);
        }

        function onSelectStart(event) {
            launchBubble();
        }

        // --- VR and Non-VR Setup ---
        camera.position.set(0, 0, 0);

        // VR Support check
        let vrButton = document.getElementById('enterVRButton');
        let statusText = document.getElementById('status');

        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                vrButton.disabled = !supported;
                vrButton.textContent = supported ? 'Enter VR' : 'VR not supported';
            });
        }
        else {
            vrButton.disabled = true;
            vrButton.textContent = 'VR not supported';
        }

        vrButton.addEventListener('click', function() {
            if (renderer.xr.isPresenting) {
                renderer.xr.getSession().end();
                vrButton.textContent = 'Enter VR';

              //Detach the gun if exiting VR
               if (aimingGun.parent) {
                    aimingGun.parent.remove(aimingGun);
                    scene.add(aimingGun);
                    aimingGun.position.set(0, -5, 0);
                }


            } else {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                }).then(function(session) {
                    renderer.xr.setSession(session);
                    vrButton.textContent = 'Exit VR';
                    setupVRControllers();
                }).catch(function(error) {
                    console.error("Failed to start VR", error);
                });
            }
        });


        // --- Main Game Loop ---
        function animate() {
            renderer.setAnimationLoop(render);
        }


        function render() {
            if (shootingBubble && shootingBubble.userData.isShooting) {
                shootingBubble.position.addScaledVector(shotDirection, SHOT_SPEED / 60);

                const collision = checkCollision(shootingBubble);
                if (collision) {
                    shootingBubble.userData.isShooting = false;
                    const newPos = placeBubble(shootingBubble, collision);

                    if (newPos) {
                        const matches = checkMatches(newPos.row, newPos.col);
                        removeMatches(matches);
                    }

                    resetShootingBubble();
                    checkLevelUp();

                } else if (shootingBubble.position.length() > 50) { // Out of bounds
                    shootingBubble.userData.isShooting = false;
                    resetShootingBubble();
                }
            }

            renderer.render(scene, camera);
        }


        // --- Initialize Game ---
        populateGrid();
        resetShootingBubble();
        animate();

        // --- Event Listeners ---
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth / window.innerHeight);
        });

    </script>
</body>
</html>

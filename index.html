<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Bubble Shooter - Limit!</title>
    <script src="./three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px 0;
            cursor: pointer;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button id="enterVRButton">Enter VR</button>
        <p id="instructions">Aim and shoot bubbles to match colors! Powerups spawn randomly.</p>
        <p id="score">Score: 0</p>
        <p id="level">Level: 1</p>
    </div>

    <script>
        // --- Constants ---
        const BUBBLE_RADIUS = 0.5;
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 15; // Increased grid height
        const COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff69b4]; // Added Pink
        const SHOT_SPEED = 15;
        const ROW_OFFSET = BUBBLE_RADIUS * Math.sqrt(3);
        const POWERUP_CHANCE = 0.05; // Chance to spawn a power-up
        const POWERUP_DURATION = 5000; //Power-up duration (milliseconds)

        // --- Power-up Types ---
        const POWERUP_TYPES = {
            CLEAR_ROW: "CLEAR_ROW",
            COLOR_BOMB: "COLOR_BOMB",
            SCORE_BOOST: "SCORE_BOOST"
        };

        // --- Game State ---
        let score = 0;
        let level = 1;
        let bubbleGrid = [];
        let shootingBubble = null;
        let shotDirection = new THREE.Vector3(0, 0, 0);
        let activePowerup = null;  // Track active power-up
        let powerupEndTime = 0;

        // --- UI Elements ---
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);


        // --- Bubble Creation and Grid Management ---
        function createBubble(x, y, color, isPowerup = false) {
            const geometry = new THREE.SphereGeometry(BUBBLE_RADIUS, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const bubble = new THREE.Mesh(geometry, material);

            bubble.position.set(x, y, -10);
            bubble.userData = { color: color, isPowerup: isPowerup };
            return bubble;
        }


        function getRandomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        function createRandomBubble(x, y) {
            const isPowerup = Math.random() < POWERUP_CHANCE;
            const color = isPowerup ? 0xffffff : getRandomColor(); // White for Power-ups
            return createBubble(x, y, color, isPowerup);
        }

        function populateGrid() {
            bubbleGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(null)); // Initialize 2D array

            for (let row = 0; row < 5; row++) { //Initial rows only
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const x = col * 2 * BUBBLE_RADIUS + (row % 2) * BUBBLE_RADIUS;
                    const y = row * ROW_OFFSET;

                    const bubble = createRandomBubble(x - (GRID_WIDTH * BUBBLE_RADIUS), y - (GRID_HEIGHT * ROW_OFFSET / 2));

                    bubbleGrid[row][col] = bubble;
                    scene.add(bubble);
                }
            }
        }

        function resetGrid() {
            bubbleGrid.forEach(row => row.forEach(bubble => {
                if (bubble) scene.remove(bubble);
            }));
            bubbleGrid = [];
            populateGrid();
        }

        // --- Shooting ---
        function createShootingBubble() {
            const isPowerup = Math.random() < POWERUP_CHANCE;
            const color = isPowerup ? 0xffffff : getRandomColor(); // White for Power-ups
            const bubble = createBubble(0, -5, color, isPowerup);
            return bubble;
        }

        function resetShootingBubble() {
            if (shootingBubble) scene.remove(shootingBubble);
            shootingBubble = createShootingBubble();
            scene.add(shootingBubble);
        }

        function launchBubble(direction) {
            if (shootingBubble) {
                shotDirection.copy(direction).normalize();
                shootingBubble.userData.isShooting = true;
            }
        }

        // --- Collision and Placement ---
        function checkCollision(bubble) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const existingBubble = bubbleGrid[row][col];
                    if (existingBubble) {
                        const distance = bubble.position.distanceTo(existingBubble.position);
                        if (distance < 2 * BUBBLE_RADIUS) {
                            return { row: row, col: col };
                        }
                    }
                }
            }
            return null;
        }


        function placeBubble(bubble, collision) {
            if (!collision) return null;

            let newRow = collision.row;
            let newCol = collision.col;

            // More sophisticated placement logic
            let placed = false;
            const adjacentPositions = [
                { row: newRow, col: newCol - 1 },
                { row: newRow, col: newCol + 1 },
                { row: newRow - 1, col: newCol + (newRow % 2) },
                { row: newRow - 1, col: newCol - 1 + (newRow % 2) },
                { row: newRow + 1, col: newCol + (newRow % 2) },
                { row: newRow + 1, col: newCol - 1 + (newRow % 2) }
            ];

            for (const pos of adjacentPositions) {
                if (pos.row >= 0 && pos.row < GRID_HEIGHT && pos.col >= 0 && pos.col < GRID_WIDTH && !bubbleGrid[pos.row][pos.col]) {

                    newRow = pos.row;
                    newCol = pos.col;
                    placed = true;
                    break;  // Place in the first available spot
                }
            }

            if (!placed) return null;  // No place to put it!

            // Calculate world position based on grid
            const x = newCol * 2 * BUBBLE_RADIUS + (newRow % 2) * BUBBLE_RADIUS;
            const y = newRow * ROW_OFFSET;

            bubble.position.x = x - (GRID_WIDTH * BUBBLE_RADIUS);
            bubble.position.y = y - (GRID_HEIGHT * ROW_OFFSET / 2);
            bubble.position.z = -10; //Ensure correct z

            bubble.userData.isShooting = false;
            bubbleGrid[newRow][newCol] = bubble;

            return { row: newRow, col: newCol };
        }


        // --- Matching and Power-ups ---
        function checkMatches(startRow, startCol) {
            const startBubble = bubbleGrid[startRow][startCol];
            if (!startBubble || startBubble.userData.isPowerup) return []; // Don't match Power-ups directly

            const matchedBubbles = [];
            const visited = {};
            const color = startBubble.userData.color;

            function explore(row, col) {
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) return;
                if (visited[row + ',' + col]) return;

                const bubble = bubbleGrid[row][col];
                if (!bubble || bubble.userData.isPowerup || bubble.userData.color !== color) return;  // Skip powerups

                visited[row + ',' + col] = true;
                matchedBubbles.push(bubble);

                //Check if matching to powerup.

                explore(row + 1, col);
                explore(row - 1, col);
                explore(row, col + 1);
                explore(row, col - 1);

                // Hexagonal
                if (row % 2 === 0) {
                    explore(row - 1, col - 1);
                    explore(row + 1, col - 1);
                } else {
                    explore(row - 1, col + 1);
                    explore(row + 1, col + 1);
                }
            }

            explore(startRow, startCol);
            return matchedBubbles;
        }

       function triggerPowerup(bubble) {
            if (!bubble.userData.isPowerup) return;

            const type = Object.values(POWERUP_TYPES)[Math.floor(Math.random() * Object.values(POWERUP_TYPES).length)];  // Random powerup type

            activePowerup = type;
            powerupEndTime = Date.now() + POWERUP_DURATION;

            console.log("Power-up activated:", type);

            switch (type) {
                case POWERUP_TYPES.CLEAR_ROW:
                    clearBottomRow();
                    break;
                case POWERUP_TYPES.COLOR_BOMB:
                    clearByColor(bubble.userData.color);
                    break;
                case POWERUP_TYPES.SCORE_BOOST:
                    increaseScore(500);
                    break;
                default:
                    console.warn("Unknown powerup type:", type);
            }
        }


        function removeMatches(matches) {
            if (matches.length >= 3) {
                matches.forEach(bubble => {
                    for (let row = 0; row < GRID_HEIGHT; row++) {
                        for (let col = 0; col < GRID_WIDTH; col++) {
                            if (bubbleGrid[row][col] === bubble) {
                                scene.remove(bubble);
                                bubbleGrid[row][col] = null;
                                increaseScore(10);
                            }
                        }
                    }
                });
            }
        }


        function increaseScore(amount) {
            score += amount;
            scoreElement.textContent = 'Score: ' + score;
        }


        function clearBottomRow() {
            const bottomRow = bubbleGrid[GRID_HEIGHT - 1];
            if (bottomRow) {
                bottomRow.forEach(bubble => {
                    if (bubble) {
                        scene.remove(bubble);
                    }
                });
                bubbleGrid[GRID_HEIGHT - 1] = Array(GRID_WIDTH).fill(null);  // Clear the row
            }
        }

       function clearByColor(color) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const bubble = bubbleGrid[row][col];
                    if (bubble && bubble.userData.color === color) {
                        scene.remove(bubble);
                        bubbleGrid[row][col] = null;
                        increaseScore(20);
                    }
                }
            }
        }

        function checkAndHandlePowerup(startRow, startCol) {
             const startBubble = bubbleGrid[startRow][startCol];

             if(startBubble && startBubble.userData.isPowerup) {
                triggerPowerup(startBubble);
             }

        }


        // --- Level Management ---
        function checkLevelUp() {
            // Simple logic: If a certain number of bubbles are cleared, level up
            const clearedBubbles = bubbleGrid.flat().filter(bubble => bubble === null).length;
            if (clearedBubbles > level * 20) {
                level++;
                levelElement.textContent = 'Level: ' + level;
                resetGrid(); // Reset grid to increase the difficulty and bubble count
            }
        }



        // --- VR Controller Setup ---
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            scene.add(controller2);

            const controllerModelFactory = new THREE.XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(geometry);
            line.scale.z = 10;
            controller1.add(line.clone());
            controller2.add(line.clone());
        }

        function onSelectStart(event) {
            const controller = event.target;
            const direction = new THREE.Vector3();
            controller.getWorldDirection(direction);
            launchBubble(direction);
        }


        // --- VR and Non-VR Setup ---
        camera.position.set(0, 0, 0);

        // VR Support check
        let vrButton = document.getElementById('enterVRButton');
        let statusText = document.getElementById('status');

        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                vrButton.disabled = !supported;
                vrButton.textContent = supported ? 'Enter VR' : 'VR not supported';
            });
        }
        else {
            vrButton.disabled = true;
            vrButton.textContent = 'VR not supported';
        }


        vrButton.addEventListener('click', function() {
            if (renderer.xr.isPresenting) {
                renderer.xr.getSession().end();
                vrButton.textContent = 'Enter VR';
            } else {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                }).then(function(session) {
                    renderer.xr.setSession(session);
                    vrButton.textContent = 'Exit VR';
                    setupVRControllers();
                }).catch(function(error) {
                    console.error("Failed to start VR", error);
                });
            }
        });


        // --- Main Game Loop ---
        function animate() {
            renderer.setAnimationLoop(render);
        }


        function render() {
            if (shootingBubble && shootingBubble.userData.isShooting) {
                shootingBubble.position.addScaledVector(shotDirection, SHOT_SPEED / 60);

                const collision = checkCollision(shootingBubble);
                if (collision) {
                    shootingBubble.userData.isShooting = false;
                    const newPos = placeBubble(shootingBubble, collision);


                    if (newPos) {
                        //This is where any code that needs to be triggered right after placing a bubble goes.
                        checkAndHandlePowerup(newPos.row, newPos.col);
                        const matches = checkMatches(newPos.row, newPos.col);
                        removeMatches(matches);

                    }


                    resetShootingBubble();
                    checkLevelUp();


                } else if (shootingBubble.position.length() > 50) { // Out of bounds
                    shootingBubble.userData.isShooting = false;
                    resetShootingBubble();
                }
            }


            //Powerup Timout Check
            if (activePowerup && Date.now() > powerupEndTime) {
                activePowerup = null;
                console.log("Power-up expired");
            }
            renderer.render(scene, camera);
        }


        // --- Initialize Game ---
        populateGrid();
        animate();

        // --- Event Listeners ---
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

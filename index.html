<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmic Weaver: Voice of the Void</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Orbitron', 'Arial', sans-serif; /* A bit more futuristic */
      text-align: center;
      background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c);
      color: #e0e0ff;
      margin: 0;
      padding: 0;
      overflow: hidden; /* Hide scrollbars, we're controlling the universe */
      min-height: 100vh;
      position: relative; /* For starfield */
      animation: nebulaFlow 60s infinite alternate; /* Slow down nebula */
    }

    /* Starfield - absolute positioned particles */
    #starfield {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind everything */
      pointer-events: none; /* Don't interfere with clicks */
    }

    #starfield canvas {
      width: 100%;
      height: 100%;
    }

    @keyframes nebulaFlow {
      0% { background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c); }
      33% { background: radial-gradient(circle, #c770f0, #f070c7, #a53794); }
      66% { background: radial-gradient(circle, #ff4500, #1a3b5c, #ff6ec7); }
      100% { background: radial-gradient(circle, #2a2a5c, #9b59b6, #0a0a1f); }
    }

    h1 {
      font-family: 'Cinzel', serif;
      font-size: 5rem; /* Bigger, bolder */
      color: #00ffff;
      text-shadow: 0 0 30px #ff6ec7, 0 0 60px #9b59b6, 0 0 90px #ff4500;
      animation: mantraGlow 4s infinite alternate, wobble 3s ease-in-out infinite; /* Subtle wobble */
      margin: 20px 0;
    }

    @keyframes wobble {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes mantraGlow {
      0% { text-shadow: 0 0 20px #ff6ec7, 0 0 40px #9b59b6; }
      100% { text-shadow: 0 0 40px #00ffff, 0 0 80px #ff4500; }
    }

    #mandalaCanvas {
      border: 6px solid #ff00ff;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(10, 10, 31, 0.9), rgba(26, 26, 59, 0.4));
      box-shadow: 0 0 100px rgba(255, 0, 255, 0.9), inset 0 0 50px rgba(0, 255, 255, 0.5);
      max-width: 90vw;
      max-height: 75vh; /* Less height for button bar*/
      display: block;
      margin: 20px auto;
      position: relative;
      transition: transform 0.5s ease, box-shadow 0.5s ease;
    }

    #mandalaCanvas:hover {
      transform: scale(1.1) rotate(2deg);
      box-shadow: 0 0 150px rgba(0, 255, 255, 1);
    }

    #vrCanvas {
      position: fixed; /* Fixed for VR overlay */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      display: none;
    }

    .glyph-tab {
      display: inline-block;
      padding: 10px 20px;
      background: linear-gradient(45deg, #9b59b6, #ff6ec7);
      border-radius: 10px 10px 0 0;
      color: #ffffff;
      cursor: pointer;
      text-shadow: 0 0 10px #00ffff;
      transition: all 0.3s;
    }

    .glyph-tab:hover, .glyph-tab.active {
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      color: #1a1a3b;
      transform: translateY(-5px);
    }

    .tab-content {
      display: none;
      background: rgba(10, 10, 40, 0.95);
      padding: 20px;
      border-radius: 0 0 15px 15px;
      border: 3px solid #ff6ec7;
      max-width: 900px;
      margin: 0 auto;
      box-shadow: 0 0 60px rgba(255, 0, 255, 0.7);
    }

    .tab-content.active {
      display: block;
    }

    .control-panel {
      background: linear-gradient(135deg, #1e1e3b, #ff00ff);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
    }

    .slider-container {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .slider-label {
        flex: 0 0 120px;
        text-align: left;
    }

    input[type="range"] {
        flex: 1;
    }

    button {
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      color: #1a1a3b;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.4s;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.9);
      animation: pulseButton 2s infinite alternate; /* Subtle pulse animation */
    }

    @keyframes pulseButton {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }

    button:hover {
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 1);
    }

    .intention-modal, .preset-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 40, 0.95);
      padding: 20px;
      border: 3px solid #00ffff;
      border-radius: 15px;
      z-index: 100;
      display: none;
    }

    .intention-modal.active, .preset-modal.active {
      display: block;
    }

    .intention-modal input, .preset-modal button {
      margin: 10px;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.2s; /* Hover effect */
    }

    .intention-modal input:hover, .preset-modal button:hover {
      background-color: rgba(0, 255, 255, 0.2);
    }

    #soundMeter {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 200px;
      height: 20px;
      background: #333;
      border: 2px solid #00ffff;
      border-radius: 5px;
    }

    #soundBar {
      height: 100%;
      background: linear-gradient(90deg, #ff00ff, #00ffff);
      transition: width 0.1s;
    }

    #soundInfo {
      position: fixed;
      bottom: 50px;
      left: 20px;
      color: #00ffff;
      text-shadow: 0 0 10px #ff00ff;
    }

    .controls {
      display: flex;
      justify-content: space-around;
      padding: 15px;
      background: rgba(10, 10, 40, 0.7); /* Translucent bar */
      border-radius: 10px;
      margin-top: 15px;

    }

    /* Add the pulsating button */
    .pulse-button {
        background-color: #25D366;
        border-radius: 60px;
        box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7);
        cursor: pointer;
        animation: pulse 1.25s infinite cubic-bezier(0.66, 0, 0, 1);
        padding: 15px 30px;
        color: white;
        font-size: 18px;
        border: none;
        font-weight: bold;
    }

    @keyframes pulse {
        0% {
            transform: scale(0.95);
            box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7);
        }

        70% {
            transform: scale(1);
            box-shadow: 0 0 0 10px rgba(37, 211, 102, 0);
        }

        100% {
            transform: scale(0.95);
            box-shadow: 0 0 0 0 rgba(37, 211, 102, 0);
        }
    }

  </style>
</head>
<body>
  <div id="starfield">
    <canvas></canvas>
  </div>

  <h1>Cosmic Weaver: Voice of the Void</h1>

  <div class="tab-container">
    <span class="glyph-tab active" onclick="openTab(event, 'formTab')">✴ Form</span>
    <span class="glyph-tab" onclick="openTab(event, 'freqTab')">✶ Frequency</span>
    <span class="glyph-tab" onclick="openTab(event, 'voidTab')">✹ Void</span>
  </div>

  <div id="formTab" class="tab-content active">
      <div class="control-panel">
          <div class="slider-container">
              <label class="slider-label" for="segmentsSlider">Segments:</label>
              <input type="range" id="segmentsSlider" min="3" max="30" value="3" oninput="updateParams('segments', this.value)">
          </div>
          <div class="slider-container">
              <label class="slider-label" for="levelsSlider">Levels:</label>
              <input type="range" id="levelsSlider" min="1" max="6" value="4" oninput="updateParams('levels', this.value)">
          </div>
          <div class="slider-container">
              <label class="slider-label" for="scaleFactorSlider">Scale Factor:</label>
              <input type="range" id="scaleFactorSlider" min="0.1" max="0.99" step="0.01" value="0.7" oninput="updateParams('scaleFactor', this.value)">
          </div>
          <div class="slider-container">
              <label class="slider-label" for="radiusSlider">Initial Radius:</label>
              <input type="range" id="radiusSlider" min="50" max="300" value="200" oninput="updateParams('initialRadius', this.value)">
          </div>
          <div class="slider-container">
              <label class="slider-label" for="lineWidthSlider">Line Width:</label>
              <input type="range" id="lineWidthSlider" min="1" max="10" value="3" oninput="updateParams('lineWidth', this.value)">
          </div>

          <label for="patternType">Pattern Type:</label>
          <select id="patternType" onchange="updateParams('patternType', this.value)">
              <option value="cymatic">Cymatic</option>
              <option value="vortex">Vortex</option>
              <option value="nebula">Nebula</option>
              <option value="chaos">Chaos</option>
              <option value="flower">Flower</option>
              <option value="yantra">Yantra</option>
              <option value="tunnel">Tunnel</option>
              <option value="hypercube">Hypercube</option>
              <option value="fractal">Fractal</option> <!-- NEW -->
          </select>

      </div>
  </div>
  <div id="freqTab" class="tab-content">
      <div class="control-panel">
          <div class="slider-container">
              <label class="slider-label" for="baseFreqSlider">Base Frequency:</label>
              <input type="range" id="baseFreqSlider" min="50" max="500" value="110" oninput="updateParams('baseFreq', this.value)">
          </div>
          <label for="waveform">Waveform:</label>
          <select id="waveform" onchange="updateParams('waveform', this.value)">
              <option value="sine">Sine</option>
              <option value="square">Square</option>
              <option value="sawtooth">Sawtooth</option>
              <option value="triangle">Triangle</option>
          </select>
          <div class="slider-container">
              <label class="slider-label" for="modulationSlider">Modulation:</label>
              <input type="range" id="modulationSlider" min="0" max="2" step="0.1" value="1" oninput="updateParams('modulation', this.value)">
          </div>
      </div>
  </div>
  <div id="voidTab" class="tab-content">
      <div class="control-panel">
          <label for="lineColor">Line Color:</label>
          <input type="color" id="lineColor" value="#ff00ff" oninput="updateParams('lineColor', this.value)">
          <label for="secondaryColor">Secondary Color:</label>
          <input type="color" id="secondaryColor" value="#00ffff" oninput="updateParams('secondaryColor', this.value)">
      </div>
  </div>

  <div class="controls">
    <button id="generate">Weave Cosmos</button>
    <button id="presets">Sacred Patterns</button>
    <button id="drone">Toggle Drone</button>
    <button id="journey">Guided Journey</button>
    <button id="download">Capture Void</button>
    <button id="enterVR">Enter Temple</button>
  </div>

  <div id="intentionModal" class="intention-modal">
    <label for="intentionInput">Set Your Intention:</label>
    <input type="text" id="intentionInput" placeholder="e.g., Peace, Clarity">
    <button onclick="startWithIntention()">Begin</button>
  </div>

  <div id="presetModal" class="preset-modal">
    <button onclick="applyPreset('mandala')">Tibetan Mandala</button>
    <button onclick="applyPreset('yantra')">Hindu Yantra</button>
    <button onclick="applyPreset('sufi')">Sufi Spiral</button>
    <button onclick="applyPreset('zen')">Zen Enso</button>
     <button onclick="applyPreset('kali')">Kali's Dance</button>  <!-- NEW -->
  </div>

  <div id="soundMeter"><div id="soundBar" style="width: 0%;"></div></div>
  <div id="soundInfo">Amplitude: 0% | Pitch: 0 Hz</div>

  <canvas id="mandalaCanvas" width="800" height="800"></canvas>
  <canvas id="vrCanvas"></canvas>

  <script src="./three.min.js"></script>
  <script>if (!window.THREE) document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"><\/script>');</script>
  <script>
    const mandalaCanvas = document.getElementById('mandalaCanvas');
    const ctx = mandalaCanvas.getContext('2d');
    const vrCanvas = document.getElementById('vrCanvas');
    let animationId = null;
    let audioContext, droneOscillator, droneGain, voiceAnalyser;
    let scene, camera, renderer; // Removed mandalaGroup
    let vrTexture, vrMaterial, vrPlane;
    let intention = '';
    let voicePitch = 0;
    let voiceAmplitude = 0;
    let droneAmplitude = 0;
    let rotationSpeed = 0; // Drone-driven
    let timeFactor = 0;

    const VR_PLANE_WIDTH = 16; // Adjusted based on VR viewing size
    const VR_PLANE_HEIGHT = 9; // Adjusted based on VR viewing size

    const params = {
      segments: 3, // Voice-driven
      levels: 4,
      scaleFactor: 0.7,
      initialRadius: 200,
      lineColor: '#ff00ff',
      lineWidth: 3,
      baseFreq: 110,
      waveform: 'sine',
      secondaryColor: '#00ffff',
      modulation: 1,
      patternType: 'cymatic'
    };

    //Starfield Initialization
      const starfieldCanvas = document.querySelector('#starfield canvas');
      const starfieldCtx = starfieldCanvas.getContext('2d');
      let stars = [];

      function initStarfield() {
          starfieldCanvas.width = window.innerWidth;
          starfieldCanvas.height = window.innerHeight;
          stars = [];
          for (let i = 0; i < 200; i++) {
              stars.push({
                  x: Math.random() * starfieldCanvas.width,
                  y: Math.random() * starfieldCanvas.height,
                  size: Math.random() * 3,
                  opacity: Math.random()
              });
          }
          drawStarfield();
      }

      function drawStarfield() {
          starfieldCtx.clearRect(0, 0, starfieldCanvas.width, starfieldCanvas.height);
          stars.forEach(star => {
              starfieldCtx.beginPath();
              starfieldCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
              starfieldCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
              starfieldCtx.fill();
          });
      }

      function animateStarfield() {
          stars.forEach(star => {
              star.x -= 0.1; // Subtle movement
              if (star.x < 0) star.x = starfieldCanvas.width;
          });
          drawStarfield();
          requestAnimationFrame(animateStarfield);
      }

    // Audio Initialization
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioContext.state === 'suspended') audioContext.resume();
    }

    // Drone Control
    function toggleDrone() {
      initAudio();
      if (droneOscillator) {
        droneOscillator.stop();
        droneOscillator = null;
        droneGain = null;
        droneAmplitude = 0;
        document.getElementById('drone').textContent = 'Start Drone';
      } else {
        droneOscillator = audioContext.createOscillator();
        droneGain = audioContext.createGain();
        droneOscillator.type = params.waveform;
        droneOscillator.frequency.value = params.baseFreq;
        droneGain.gain.value = 0.1;
        droneAmplitude = 0.1;
        droneOscillator.connect(droneGain).connect(audioContext.destination);
        droneOscillator.start();
        document.getElementById('drone').textContent = 'Stop Drone';
        updateDroneParams();
      }
    }

    function updateDroneParams() {
      if (droneOscillator) {
        rotationSpeed = Math.min(0.05, droneAmplitude * 0.5);
        timeFactor += droneAmplitude * 0.01;
        requestAnimationFrame(updateDroneParams);
      } else {
        rotationSpeed = 0;
        timeFactor = 0;
      }
    }

    // Voice Detection
    function initVoiceControl() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          initAudio();
          const source = audioContext.createMediaStreamSource(stream);
          voiceAnalyser = audioContext.createAnalyser();
          voiceAnalyser.fftSize = 2048;
          voiceAnalyser.smoothingTimeConstant = 0.8;
          source.connect(voiceAnalyser);

          const bufferLength = voiceAnalyser.fftSize;
          const dataArray = new Float32Array(bufferLength);

          function detectPitch() {
            voiceAnalyser.getFloatTimeDomainData(dataArray);
            const pitch = autoCorrelate(dataArray, audioContext.sampleRate);
            voiceAmplitude = getAmplitude(dataArray);

            if (pitch !== -1) voicePitch = pitch;
            else voicePitch = 0;

            updateVoiceParams();
            updateSoundMeter();
            if (droneOscillator || voiceAmplitude > 0.1) animate(); // Lowered threshold
            requestAnimationFrame(detectPitch);
          }
          detectPitch();
        })
        .catch(e => console.error('Voice control failed:', e));
    }

    function autoCorrelate(buf, sampleRate) {
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

      buf = buf.slice(r1, r2);
      SIZE = buf.length;

      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++)
        for (let j = 0; j < SIZE - i; j++)
          c[i] = c[i] + buf[j] * buf[j + i];

      let d = 0;
      while (c[d] > c[d + 1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;

      let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
      let a = (x1 + x3 - 2 * x2) / 2;
      let b = (x3 - x1) / 2;
      if (a) T0 = T0 - b / (2 * a);

      return sampleRate / T0;
    }

    function getAmplitude(buf) {
      let sum = 0;
      for (let i = 0; i < buf.length; i++) sum += Math.abs(buf[i]);
      return Math.min(1, sum / buf.length / 0.5);
    }

    let pitchHistory = [];
    function updateVoiceParams() {
      pitchHistory.push(voicePitch);
      if (pitchHistory.length > 20) pitchHistory.shift();
      const stability = voicePitchStability();

      //console.log(`Voice - Amplitude: ${voiceAmplitude}, Pitch: ${voicePitch}, Stability: ${stability}, Segments: ${params.segments}`);

      if (voiceAmplitude > 0.1 && stability > 0.8) { // Lowered threshold
          params.segments = Math.min(30, params.segments + 0.5); // Gradual increase
      } else {
          params.segments = Math.max(3, params.segments - 0.3); // Gradual decrease
      }

      // Smooth initial radius
      params.initialRadius = lerp(params.initialRadius, 200 + voiceAmplitude * 100, 0.1);

    }

    function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }


    function voicePitchStability() {
      if (pitchHistory.length < 2) return 0;
      const avg = pitchHistory.reduce((a, b) => a + b) / pitchHistory.length;
      const variance = pitchHistory.reduce((a, b) => a + Math.abs(b - avg), 0) / pitchHistory.length;
      return Math.min(1, 1 - variance / 200);
    }

    function updateSoundMeter() {
      const amplitudePercent = Math.round(voiceAmplitude * 100);
      document.getElementById('soundBar').style.width = `${amplitudePercent}%`;
      document.getElementById('soundInfo').textContent = `Amplitude: ${amplitudePercent}% | Pitch: ${Math.round(voicePitch)} Hz`;
    }


    // Simplified VR Initialization
    function initVR() {
      if (!window.THREE) {
        console.error('Three.js not loaded');
        document.getElementById('enterVR').textContent = 'VR Unavailable';
        return;
      }

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ canvas: vrCanvas, antialias: true });
      renderer.xr.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Create VR Texture from Canvas
      vrTexture = new THREE.CanvasTexture(mandalaCanvas);

      // Create VR Material
      vrMaterial = new THREE.MeshBasicMaterial({ map: vrTexture, side: THREE.DoubleSide, transparent: true });

      // Create VR Plane (the screen for the mandala)
      const geometry = new THREE.PlaneGeometry(VR_PLANE_WIDTH, VR_PLANE_HEIGHT);
      vrPlane = new THREE.Mesh(geometry, vrMaterial);
      scene.add(vrPlane);

      // Position Plane in front of User
      vrPlane.position.set(0, 2, -5); // Adjust position as needed

      //Basic Environment. Change the color or texture.
      scene.background = new THREE.Color(0x111122);

      camera.position.z = 0;

      document.getElementById('enterVR').addEventListener('click', async () => {
        try {
          const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor'] });
          session.addEventListener('end', () => {
            vrCanvas.style.display = 'none';
            renderer.setAnimationLoop(null);
            document.getElementById('enterVR').textContent = 'Enter Temple';
            params.segments = 3;
            rotationSpeed = 0;
          });
          renderer.xr.setSession(session);
          renderer.setAnimationLoop(animateVR);
          vrCanvas.style.display = 'block';
          document.getElementById('enterVR').textContent = 'Sing & Drone';
          if (!voiceAnalyser) initVoiceControl(); // Ensure voice control in VR
        } catch (err) {
          console.error('VR Failed:', err);
          document.getElementById('enterVR').textContent = 'VR Failed';
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // Simplified VR Update (No 3D mandala generation)
    function updateVRMandala() {
      // Update VR Texture from the 2D Canvas
      vrTexture.needsUpdate = true;
    }


      // Fractal Drawing Function
      function drawFractal(x, y, len, angle, depth) {
          if (depth === 0) return;

          const x1 = x + len * Math.cos(angle);
          const y1 = y + len * Math.sin(angle);

          const gradient = ctx.createLinearGradient(x, y, x1, y1);
          gradient.addColorStop(0, params.lineColor);
          gradient.addColorStop(1, params.secondaryColor);

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x1, y1);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = params.lineWidth * (1 - depth / params.levels);
          ctx.stroke();

          const splitAngle = 0.5; // Angle for branching
          const newLen = len * 0.7;   // Length reduction for branches

          drawFractal(x1, y1, newLen, angle + splitAngle, depth - 1);
          drawFractal(x1, y1, newLen, angle - splitAngle, depth - 1);
      }


    // 2D Mandala Generation
    function generateMandala(timeFactor) {
      ctx.clearRect(0, 0, mandalaCanvas.width, mandalaCanvas.height);
      const centerX = mandalaCanvas.width / 2;
      const centerY = mandalaCanvas.height / 2;
      const audioFactor = voiceAmplitude + droneAmplitude;

      function drawRecursiveShape(x, y, r, level) {
        if (level > params.levels) return;
        const gradient = ctx.createLinearGradient(x - r, y - r, x + r, y + r);
        gradient.addColorStop(0, params.lineColor);
        gradient.addColorStop(0.5, params.secondaryColor);
        gradient.addColorStop(1, params.lineColor);

        ctx.lineWidth = params.lineWidth * (1 - (level - 1) / params.levels * 0.7) * audioFactor;
        ctx.strokeStyle = gradient;
        ctx.shadowBlur = 40 * audioFactor;
        ctx.shadowColor = params.secondaryColor;

        switch (params.patternType) {
          case 'cymatic':
            ctx.beginPath();
            for (let i = 0; i < params.segments; i++) {
              const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.5;
              const mod = Math.sin(angle * level * 3 + timeFactor) * audioFactor;
              const dist = r * (0.6 + mod * 0.9);
              ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
            }
            ctx.closePath();
            ctx.stroke();
            break;
          case 'vortex':
            ctx.beginPath();
            for (let i = 0; i < params.segments / level; i++) {
              const angle = (i / (params.segments / level)) * Math.PI * 2 + timeFactor * 1.2;
              const x1 = x + r * Math.cos(angle);
              const y1 = y + r * Math.sin(angle);
              const x2 = x + r * 0.4 * Math.cos(angle + Math.PI / (params.segments / level));
              const y2 = y + r * 0.4 * Math.sin(angle + Math.PI / (params.segments / level));
              ctx.moveTo(x, y);
              ctx.quadraticCurveTo(x1, y1, x2, y2);
            }
            ctx.stroke();
            break;
          case 'nebula':
            ctx.beginPath();
            for (let i = 0< 12; i++) {
              const angle = (i / 12) * Math.PI * 2 + Math.sin(timeFactor * 0.4) * audioFactor;
              const dist = r * (0.5 + Math.cos(timeFactor + i) * 0.7 * audioFactor);
              ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
            }
            ctx.closePath();
            ctx.stroke();
            break;
          case 'chaos':
            ctx.beginPath();
            const points = Math.floor(Math.random() * 8) + 5;
            for (let i = 0; i < points; i++) {
              const angle = (i / points) * Math.PI * 2 + Math.random() * 0.6 + timeFactor;
              const dist = r * (0.3 + Math.sin(timeFactor + level) * 0.9 * audioFactor);
              ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
            }
            ctx.closePath();
            ctx.stroke();
            break;
          case 'flower':
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
              const angle = (i / 10) * Math.PI * 2 + timeFactor * 0.8;
              const dist = r * audioFactor * (0.6 + Math.sin(timeFactor) * 0.4);
              ctx.arc(x + Math.cos(angle) * r * 0.5, y + Math.sin(angle) * r * 0.5, dist * 0.3, 0, Math.PI * 2);
            }
            ctx.stroke();
            break;
          case 'yantra':
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (i / 6) * Math.PI * 2 + timeFactor * 0.5;
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(angle) * r * audioFactor, y + Math.sin(angle) * r * audioFactor);
            }
            ctx.stroke();
            break;
          case 'tunnel':
            ctx.beginPath();
            for (let i = 0; i < params.segments; i++) {
              const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.9;
              const depth = Math.sin(level * 0.6 + timeFactor) * r * 0.4 * audioFactor;
              const dist = r * (1 - level / params.levels) * (1 + Math.cos(timeFactor) * 0.3);
              ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist + depth);
            }
            ctx.closePath();
            ctx.stroke();
            break;
          case 'hypercube':
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2 + timeFactor * 1.1;
              const mod = Math.cos(level + timeFactor) * audioFactor;
              const dist = r * (0.6 + mod * 0.6);
              ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
            }
            ctx.closePath();
            ctx.stroke();
            break;
          case 'fractal':
            drawFractal(x, y, r, timeFactor, params.levels); //Use the fractal function to make the pattern.
            break;
        }

        drawRecursiveShape(x, y, r * params.scaleFactor, level + 1);
      }

      for (let i = 0; i < params.segments; i++) {
        const angle = (i / params.segments) * Math.PI * 2 + timeFactor * params.modulation;
        const x = centerX + params.initialRadius * Math.cos(angle) * audioFactor;
        const y = centerY + params.initialRadius * Math.sin(angle) * audioFactor;
        drawRecursiveShape(x, y, params.initialRadius * params.scaleFactor, 1);
      }

      ctx.fillStyle = params.secondaryColor;
      for (let i = 0; i < 50; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = params.initialRadius * (Math.random() * 0.5 + 0.5) * audioFactor;
        ctx.beginPath();
        ctx.arc(centerX + Math.cos(angle) * dist, centerY + Math.sin(angle) * dist, 2 * audioFactor, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Guided Meditation
    function startGuidedMeditation() {
      const phases = [
        { duration: 300000, pattern: 'cymatic', freq: 100, color: '#ff4500' },
        { duration: 300000, pattern: 'vortex', freq: 300, color: '#00ffff' },
        { duration: 300000, pattern: 'nebula', freq: 500, color: '#ff00ff' }
      ];
      let phaseIndex = 0;

      function nextPhase() {
        if (phaseIndex >= phases.length) return;
        const phase = phases[phaseIndex];
        params.patternType = phase.pattern;
        params.baseFreq = phase.freq;
        params.lineColor = phase.color;
        if (droneOscillator) droneOscillator.frequency.value = phase.freq;
        generateMandala(0);
        setTimeout(nextPhase, phase.duration);
        phaseIndex++;
      }
      nextPhase();
    }

    // Intention Modal
    function showIntentionModal() {
      document.getElementById('intentionModal').classList.add('active');
    }

    function startWithIntention() {
      intention = document.getElementById('intentionInput').value || 'Transcendence';
      document.getElementById('intentionModal').classList.remove('active');
      generateMandala(0);
    }

    // Preset Modal
    function showPresetModal() {      document.getElementById('presetModal').classList.add('active');
    }

    function applyPreset(preset) {
      document.getElementById('presetModal').classList.remove('active');
      switch (preset) {
        case 'mandala':
          Object.assign(params, {
            segments: 3, levels: 5, scaleFactor: 0.8, initialRadius: 250,
            lineColor: '#ff4500', secondaryColor: '#ffd700', patternType: 'cymatic',
            baseFreq: 110, waveform: 'sine', modulation: 0.5
          });
          break;
        case 'yantra':
          Object.assign(params, {
            segments: 3, levels: 3, scaleFactor: 0.6, initialRadius: 200,
            lineColor: '#8a2be2', secondaryColor: '#ff00ff', patternType: 'yantra',
            baseFreq: 136.1, waveform: 'triangle', modulation: 1
          });
          break;
        case 'sufi':
          Object.assign(params, {
            segments: 3, levels: 4, scaleFactor: 0.7, initialRadius: 300,
            lineColor: '#00ced1', secondaryColor: '#228b22', patternType: 'vortex',
            baseFreq: 174, waveform: 'sawtooth', modulation: 1.5
          });
          break;
        case 'zen':
          Object.assign(params, {
            segments: 3, levels: 1, scaleFactor: 0.9, initialRadius: 150,
            lineColor: '#000000', secondaryColor: '#ffffff', patternType: 'flower',
            baseFreq: 0, waveform: 'sine', modulation: 0
          });
          break;
         case 'kali':  // Added Preset.
           Object.assign(params, {
             segments: 8, levels: 5, scaleFactor: 0.65, initialRadius: 280,
             lineColor: '#ff0000', secondaryColor: '#000000', patternType: 'chaos',
             baseFreq: 440, waveform: 'square', modulation: 1.2
           });
           break;
      }
      if (droneOscillator) droneOscillator.frequency.value = params.baseFreq;
      generateMandala(0);
      updateVRMandala();
    }

      //Parameter updating from the tab controls
      function updateParams(param, value) {
          if (param === 'scaleFactor') {
              params[param] = parseFloat(value);
          } else if (param === 'segments' || param === 'levels' || param === 'initialRadius' || param === 'lineWidth' || param === 'baseFreq') {
              params[param] = parseInt(value);
          } else {
              params[param] = value; // Color and waveform are strings
          }
      }


    // Utility Functions
    function downloadMandala() {
      const link = document.createElement('a');
      link.download = 'cosmic-spiral.png';
      link.href = mandalaCanvas.toDataURL('image/png');
      link.click();
    }

      function animate() {
          generateMandala(timeFactor);
          timeFactor += 0.01; // Continue the time factor.

          if (voiceAmplitude > 0.1 || droneOscillator) {
              animationId = requestAnimationFrame(animate);
          } else {
              cancelAnimationFrame(animationId);
              generateMandala(0);
          }
      }

    function animateVR(time) {
      updateVRMandala();
      timeFactor += 0.01;
      renderer.render(scene, camera);
    }

    function openTab(evt, tabName) {
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.glyph-tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById(tabName).classList.add('active');
      evt.currentTarget.classList.add('active');
    }

    // Initialization
    function init() {
      document.getElementById('generate').addEventListener('click', () => { showIntentionModal(); });
      document.getElementById('presets').addEventListener('click', showPresetModal);
      document.getElementById('drone').addEventListener('click', toggleDrone);
      document.getElementById('journey').addEventListener('click', startGuidedMeditation);
      document.getElementById('download').addEventListener('click', downloadMandala);

      initVoiceControl(); // Start voice early
      initVR();
      generateMandala(0);
      animate();

      initStarfield();
      animateStarfield();
    }

    window.onload = init;
    window.addEventListener('resize', initStarfield); // Adjust starfield on resize

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spiritual Machine: Infinite Spiral Weaver</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      text-align: center;
      background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c);
      color: #e0e0ff;
      margin: 0;
      padding: 20px;
      overflow: hidden;
      animation: voidShift 20s infinite alternate;
    }

    @keyframes voidShift {
      0% { background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c); }
      50% { background: radial-gradient(circle, #ff00ff, #00ffff, #ff6ec7); }
      100% { background: radial-gradient(circle, #1a3b5c, #5c2a7d, #ff4500); }
    }

    h1 {
      font-size: 3.5rem;
      color: #00ffff;
      text-shadow: 0 0 20px #ff6ec7, 0 0 40px #9b59b6, 0 0 60px #00ffff;
      animation: resonate 1.5s infinite alternate;
      margin-bottom: 30px;
    }

    @keyframes resonate {
      0% { text-shadow: 0 0 15px #ff6ec7, 0 0 30px #9b59b6; }
      100% { text-shadow: 0 0 30px #00ffff, 0 0 60px #ff4500; }
    }

    #mandalaCanvas {
      border: 4px solid #ff00ff;
      border-radius: 20px;
      background: radial-gradient(circle, rgba(10, 10, 31, 0.8), rgba(26, 26, 59, 0.5));
      box-shadow: 0 0 70px rgba(255, 0, 255, 0.8), inset 0 0 30px rgba(0, 255, 255, 0.3);
      transition: transform 0.3s, box-shadow 0.3s;
      max-width: 100%;
      z-index: 1;
    }

    #mandalaCanvas:hover {
      transform: scale(1.05);
      box-shadow: 0 0 100px rgba(0, 255, 255, 0.9);
    }

    #vrCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      display: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      background: rgba(10, 10, 40, 0.9);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.6);
      margin-top: 20px;
      border: 2px solid #00ffff;
      z-index: 3;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .control-panel {
      background: linear-gradient(135deg, #1e1e3b, #ff00ff);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      border: 2px solid #9b59b6;
    }

    button, select {
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      color: #1a1a3b;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.4s;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
    }

    button:hover, select:hover {
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      transform: scale(1.1);
      box-shadow: 0 0 25px rgba(0, 255, 255, 1);
    }

    select {
      appearance: none;
      padding-right: 25px;
      background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ffff" height="20" viewBox="0 0 24 24" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    input[type="range"] {
      background: linear-gradient(90deg, #ff6ec7, #9b59b6);
      border-radius: 8px;
      padding: 5px;
      accent-color: #00ffff;
    }

    input[type="color"] {
      width: 50px;
      height: 35px;
      border: 2px solid #00ffff;
      border-radius: 8px;
      background: none;
      cursor: pointer;
      box-shadow: 0 0 10px #ff00ff;
    }

    label {
      color: #00ffff;
      font-size: 14px;
      text-shadow: 0 0 6px #ff6ec7;
    }

    .parameter_input {
      padding: 10px;
    }

    .tab-container {
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .tab {
      background: linear-gradient(45deg, #9b59b6, #ff6ec7);
      padding: 10px 20px;
      border-radius: 8px 8px 0 0;
      color: #ffffff;
      cursor: pointer;
      text-shadow: 0 0 5px #00ffff;
    }

    .tab.active {
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      color: #1a1a3b;
    }

    .tab-content {
      display: none;
      background: rgba(10, 10, 40, 0.9);
      padding: 15px;
      border-radius: 0 0 10px 10px;
      border: 2px solid #ff6ec7;
    }

    .tab-content.active {
      display: block;
    }
  </style>
</head>
<body>
  <h1>Spiritual Machine: Infinite Spiral Weaver</h1>

  <canvas id="mandalaCanvas" width="800" height="800"></canvas>
  <canvas id="vrCanvas"></canvas>

  <div class="tab-container">
    <button class="tab active" onclick="openTab(event, 'formTab')">Form</button>
    <button class="tab" onclick="openTab(event, 'freqTab')">Frequencies</button>
    <button class="tab" onclick="openTab(event, 'voidTab')">Void</button>
  </div>

  <div id="formTab" class="tab-content active">
    <div class="control-panel">
      <div class="controls">
        <div class="parameter_input">
          <label for="segments">Segments</label>
          <input type="range" id="segments" value="12" min="3" max="50" oninput="updateValue('segments')">
          <span id="segments-value">12</span>
        </div>
        <div class="parameter_input">
          <label for="levels">Levels</label>
          <input type="range" id="levels" value="4" min="1" max="15" oninput="updateValue('levels')">
          <span id="levels-value">4</span>
        </div>
        <div class="parameter_input">
          <label for="scaleFactor">Twist</label>
          <input type="range" id="scaleFactor" value="0.7" min="0.3" max="0.9" step="0.01" oninput="updateValue('scaleFactor')">
          <span id="scaleFactor-value">0.7</span>
        </div>
        <div class="parameter_input">
          <label for="initialRadius">Amplitude</label>
          <input type="range" id="initialRadius" value="200" min="50" max="400" oninput="updateValue('initialRadius')">
          <span id="initialRadius-value">200</span>
        </div>
        <div class="parameter_input">
          <label for="lineColor">Glow</label>
          <input type="color" id="lineColor" value="#ff00ff">
        </div>
      </div>
    </div>
  </div>

  <div id="freqTab" class="tab-content">
    <div class="control-panel">
      <div class="controls">
        <div class="parameter_input">
          <label for="lineWidth">Density</label>
          <input type="range" id="lineWidth" value="3" min="1" max="10" step="0.1" oninput="updateValue('lineWidth')">
          <span id="lineWidth-value">3</span>
        </div>
        <div class="parameter_input">
          <label for="baseFreq">Base Freq</label>
          <input type="range" id="baseFreq" value="200" min="20" max="1000" step="10" oninput="updateValue('baseFreq')">
          <span id="baseFreq-value">200</span>
        </div>
        <div class="parameter_input">
          <label for="freqMultiplier">Warp</label>
          <input type="range" id="freqMultiplier" value="1.5" min="1" max="3" step="0.1" oninput="updateValue('freqMultiplier')">
          <span id="freqMultiplier-value">1.5</span>
        </div>
        <div class="parameter_input">
          <label for="waveform">Essence</label>
          <select id="waveform">
            <option value="sine">Sine</option>
            <option value="sawtooth">Saw</option>
            <option value="square">Square</option>
            <option value="triangle">Triangle</option>
          </select>
        </div>
        <div class="parameter_input">
          <label for="secondaryColor">Echo</label>
          <input type="color" id="secondaryColor" value="#00ffff">
        </div>
      </div>
    </div>
  </div>

  <div id="voidTab" class="tab-content">
    <div class="control-panel">
      <div class="controls">
        <div class="parameter_input">
          <label for="modulation">Flux</label>
          <input type="range" id="modulation" value="1" min="0.1" max="3" step="0.1" oninput="updateValue('modulation')">
          <span id="modulation-value">1</span>
        </div>
        <div class="parameter_input">
          <label for="patternType">Realm</label>
          <select id="patternType">
            <option value="cymatic">Cymatic Pulse</option>
            <option value="vortex">Vortex Spiral</option>
            <option value="nebula">Nebula Drift</option>
            <option value="chaos">Chaos Rift</option>
            <option value="flower">Flower of Eternity</option>
            <option value="yantra">Yantra Portal</option>
            <option value="tunnel">Spiral Tunnel</option>
            <option value="hypercube">Hypercube Flux</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="generate">Weave Infinity</button>
    <button id="random">Rift Chaos</button>
    <button id="animate">Pulse Cosmos</button>
    <button id="download">Capture Eternity</button>
    <button id="enterVR">Dive into VR</button>
  </div>

  <script src="three.min.js"></script>
  <script>
    const mandalaCanvas = document.getElementById('mandalaCanvas');
    const ctx = mandalaCanvas.getContext('2d');
    const vrCanvas = document.getElementById('vrCanvas');
    let animationId = null;
    let isAnimating = false;
    let audioContext, oscillators = [], lfo, analyser;
    let scene, camera, renderer, spiralTunnel;

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        console.log('AudioContext created');
      }
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('AudioContext resumed');
          updateFrequencies();
        });
      } else {
        updateFrequencies();
      }
    }

    function updateFrequencies() {
      oscillators.forEach(osc => osc.stop());
      if (lfo) lfo.stop();
      oscillators = [];

      const baseFreq = parseFloat(document.getElementById('baseFreq').value);
      const freqMultiplier = parseFloat(document.getElementById('freqMultiplier').value);
      const waveform = document.getElementById('waveform').value;
      const segments = parseInt(document.getElementById('segments').value);
      const modulation = parseFloat(document.getElementById('modulation').value);

      const beatFreq = 12 * modulation;
      for (let i = 0; i < Math.min(segments, 8); i++) {
        const oscLeft = audioContext.createOscillator();
        const oscRight = audioContext.createOscillator();
        const panLeft = audioContext.createPanner();
        const panRight = audioContext.createPanner();
        const gain = audioContext.createGain();

        oscLeft.type = waveform;
        oscRight.type = waveform;
        oscLeft.frequency.value = baseFreq * Math.pow(freqMultiplier, i);
        oscRight.frequency.value = oscLeft.frequency.value + beatFreq;
        panLeft.setPosition(-1 + i * 0.2, Math.sin(i), Math.cos(i));
        panRight.setPosition(1 - i * 0.2, Math.cos(i), Math.sin(i));
        gain.gain.value = 0.05 / (i + 1);

        oscLeft.connect(gain).connect(panLeft).connect(audioContext.destination);
        oscRight.connect(gain).connect(panRight).connect(analyser).connect(audioContext.destination);
        oscLeft.start();
        oscRight.start();
        oscillators.push(oscLeft, oscRight);
      }

      lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = modulation * 2;
      lfoGain.gain.value = 20;
      lfo.connect(lfoGain);
      oscillators.forEach(osc => lfoGain.connect(osc.frequency));
      lfo.start();
      console.log('Frequencies updated');
    }

    function initVR() {
      if (!window.THREE) {
        console.error('Three.js not loaded');
        document.getElementById('enterVR').textContent = 'VR Unavailable';
        document.getElementById('enterVR').disabled = true;
        return;
      }

      const gl = vrCanvas.getContext('webgl') || vrCanvas.getContext('experimental-webgl');
      if (!gl) {
        console.error('WebGL not supported');
        alert('WebGL not supported');
        document.getElementById('enterVR').textContent = 'VR Not Supported';
        document.getElementById('enterVR').disabled = true;
        return;
      }

      console.log('WebGL context created');
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
      try {
        renderer = new THREE.WebGLRenderer({ canvas: vrCanvas, antialias: true, context: gl });
        renderer.xr.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        console.log('WebGLRenderer initialized');
      } catch (e) {
        console.error('Renderer failed:', e);
        alert('WebGL rendering failed: ' + e.message);
        document.getElementById('enterVR').textContent = 'VR Failed';
        document.getElementById('enterVR').disabled = true;
        return;
      }

      const vertexShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        uniform float audioFactor;
        uniform float segments;
        uniform float levels;
        void main() {
          vUv = uv;
          vPosition = position;
          vec3 pos = position;
          float spiral1 = sin(pos.z * segments * 0.1 + time) * audioFactor;
          float spiral2 = cos(pos.z * levels * 0.05 + time) * audioFactor;
          pos.x += (spiral1 + spiral2) * 2.0;
          pos.y += (spiral1 - spiral2) * 2.0;
          pos.z += sin(time + pos.x) * audioFactor * 0.5 + cos(time + pos.y) * 0.3;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;
      const fragmentShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        uniform float audioFactor;
        uniform vec3 color1;
        uniform vec3 color2;
        void main() {
          float pulse = sin(vUv.x * 20.0 + time * 2.0) * cos(vUv.y * 15.0 + time) * audioFactor;
          vec3 color = mix(color1, color2, abs(pulse));
          float glow = 1.0 + sin(time + vPosition.z * 5.0) * audioFactor * 1.5;
          float noise = fract(sin(dot(vUv.xy, vec2(12.9898, 78.233))) * 43758.5453) * 0.2;
          gl_FragColor = vec4(color * glow + noise, 0.8 + audioFactor * 0.2);
        }
      `;

      const points = [];
      const levels = parseInt(document.getElementById('levels').value);
      for (let z = -50; z < 50; z += 0.5) {
        const angle = z * 0.2;
        const radius = 5 + Math.sin(z * levels * 0.1) * 3 + Math.cos(z * 0.5) * 2;
        points.push(new THREE.Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          z
        ));
      }
      const geometry = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 200, 5, 32, true);
      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          time: { value: 0 },
          audioFactor: { value: 1 },
          segments: { value: parseInt(document.getElementById('segments').value) },
          levels: { value: levels },
          color1: { value: new THREE.Color('#ff00ff') },
          color2: { value: new THREE.Color('#00ffff') }
        },
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      spiralTunnel = new THREE.Mesh(geometry, material);
      scene.add(spiralTunnel);
      camera.position.z = -10;
      console.log('VR tunnel created');

      document.getElementById('enterVR').addEventListener('click', async () => {
        if (!navigator.xr) {
          console.error('WebXR not supported');
          alert('VR not supported');
          return;
        }
        try {
          const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor'] });
          renderer.xr.setSession(session);
          renderer.setAnimationLoop(animateVR);
          vrCanvas.style.display = 'block';
          console.log('VR session started');
          document.getElementById('enterVR').textContent = 'VR Active';
        } catch (err) {
          console.error('VR failed:', err);
          alert('Failed to enter VR: ' + err.message);
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animateVR() {
      const audioFactor = getAudioFactor();
      const time = performance.now() * 0.001;
      spiralTunnel.material.uniforms.time.value = time;
      spiralTunnel.material.uniforms.audioFactor.value = audioFactor;
      spiralTunnel.material.uniforms.segments.value = parseInt(document.getElementById('segments').value);
      spiralTunnel.material.uniforms.levels.value = parseInt(document.getElementById('levels').value);
      spiralTunnel.material.uniforms.color1.value.setStyle(document.getElementById('lineColor').value);
      spiralTunnel.material.uniforms.color2.value.setStyle(document.getElementById('secondaryColor').value);
      spiralTunnel.rotation.z += 0.01 * audioFactor;
      camera.position.z += 0.1 * audioFactor;
      if (camera.position.z > 50) camera.position.z = -50;
      renderer.render(scene, camera);
    }

    function init() {
      console.log('Init started');
      document.getElementById('generate').addEventListener('click', () => {
        generateMandala();
        initAudio();
      });
      document.getElementById('random').addEventListener('click', () => {
        randomizeMandala();
        initAudio();
      });
      document.getElementById('download').addEventListener('click', downloadMandala);
      document.getElementById('animate').addEventListener('click', toggleAnimation);
      updateValueDisplays();
      initVR();
      generateMandala();
      console.log('Init completed');
    }

    function updateValueDisplays() {
      document.getElementById('segments-value').textContent = document.getElementById('segments').value;
      document.getElementById('levels-value').textContent = document.getElementById('levels').value;
      document.getElementById('scaleFactor-value').textContent = document.getElementById('scaleFactor').value;
      document.getElementById('initialRadius-value').textContent = document.getElementById('initialRadius').value;
      document.getElementById('lineWidth-value').textContent = document.getElementById('lineWidth').value;
      document.getElementById('baseFreq-value').textContent = document.getElementById('baseFreq').value;
      document.getElementById('freqMultiplier-value').textContent = document.getElementById('freqMultiplier').value;
      document.getElementById('modulation-value').textContent = document.getElementById('modulation').value;
    }

    function updateValue(id) {
      updateValueDisplays();
      if (!isAnimating) generateMandala();
      if (['baseFreq', 'freqMultiplier', 'waveform', 'segments', 'modulation'].includes(id) && audioContext) updateFrequencies();
    }

    function getAudioFactor() {
      if (!analyser) return 1;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
      return 1 + (avg / 255) * 2;
    }

    function generateMandala(timeFactor = 0) {
      console.log('Generating mandala...');
      ctx.clearRect(0, 0, mandalaCanvas.width, mandalaCanvas.height);

      const segments = parseInt(document.getElementById('segments').value);
      const levels = parseInt(document.getElementById('levels').value);
      const scaleFactor = parseFloat(document.getElementById('scaleFactor').value);
      const radius = Math.min(parseInt(document.getElementById('initialRadius').value), 400);
      const lineColor = document.getElementById('lineColor').value;
      const secondaryColor = document.getElementById('secondaryColor').value;
      const lineWidth = parseFloat(document.getElementById('lineWidth').value);
      const patternType = document.getElementById('patternType').value;
      const modulation = parseFloat(document.getElementById('modulation').value);
      const audioFactor = getAudioFactor();

      const centerX = mandalaCanvas.width / 2;
      const centerY = mandalaCanvas.height / 2;

      function drawRecursiveShape(x, y, r, level) {
        if (level > levels) return;

        const gradient = ctx.createLinearGradient(x - r, y - r, x + r, y + r);
        gradient.addColorStop(0, lineColor);
        gradient.addColorStop(0.5, secondaryColor);
        gradient.addColorStop(1, lineColor);

        ctx.lineWidth = lineWidth * (1 - (level-1) / levels * 0.7) * audioFactor;
        ctx.strokeStyle = gradient;
        ctx.shadowBlur = 40 * audioFactor;
        ctx.shadowColor = secondaryColor;

        switch (patternType) {
          case 'cymatic': drawCymatic(x, y, r, level, timeFactor); break;
          case 'vortex': drawVortex(x, y, r, segments / level, timeFactor); break;
          case 'nebula': drawNebula(x, y, r, timeFactor); break;
          case 'chaos': drawChaos(x, y, r, level, timeFactor); break;
          case 'flower': drawFlower(x, y, r, timeFactor); break;
          case 'yantra': drawYantra(x, y, r, timeFactor); break;
          case 'tunnel': drawTunnel(x, y, r, level, timeFactor); break;
          case 'hypercube': drawHypercube(x, y, r, level, timeFactor); break;
        }

        drawRecursiveShape(x, y, r * scaleFactor, level + 1);
      }

      function drawCymatic(x, y, r, level, time) {
        ctx.beginPath();
        for (let i = 0; i < segments; i++) {
          const angle = (i / segments) * Math.PI * 2 + time * 0.5;
          const mod = Math.sin(angle * level * 3 + time) * audioFactor;
          const dist = r * (0.6 + mod * 0.9);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function drawVortex(x, y, r, segments, time) {
        ctx.beginPath();
        for (let i = 0; i < segments; i++) {
          const angle = (i / segments) * Math.PI * 2 + time * 1.2;
          const x1 = x + r * Math.cos(angle);
          const y1 = y + r * Math.sin(angle);
          const x2 = x + r * 0.4 * Math.cos(angle + Math.PI / segments);
          const y2 = y + r * 0.4 * Math.sin(angle + Math.PI / segments);
          ctx.moveTo(x, y);
          ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        ctx.stroke();
      }

      function drawNebula(x, y, r, time) {
        ctx.beginPath();
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2 + Math.sin(time * 0.4) * audioFactor;
          const dist = r * (0.5 + Math.cos(time + i) * 0.7 * audioFactor);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function drawChaos(x, y, r, level, time) {
        ctx.beginPath();
        const points = Math.floor(Math.random() * 8) + 5;
        for (let i = 0; i < points; i++) {
          const angle = (i / points) * Math.PI * 2 + Math.random() * 0.6 + time;
          const dist = r * (0.3 + Math.sin(time + level) * 0.9 * audioFactor);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function drawFlower(x, y, r, time) {
        ctx.beginPath();
        for (let i = 0; i < 10; i++) {
          const angle = (i / 10) * Math.PI * 2 + time * 0.8;
          const dist = r * audioFactor * (0.6 + Math.sin(time) * 0.4);
          ctx.arc(x + Math.cos(angle) * r * 0.5, y + Math.sin(angle) * r * 0.5, dist * 0.3, 0, Math.PI * 2);
        }
        ctx.stroke();
      }

      function drawYantra(x, y, r, time) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 + time * 0.5;
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * r * audioFactor, y + Math.sin(angle) * r * audioFactor);
        }
        ctx.stroke();
      }

      function drawTunnel(x, y, r, level, time) {
        ctx.beginPath();
        for (let i = 0; i < segments; i++) {
          const angle = (i / segments) * Math.PI * 2 + time * 0.9;
          const depth = Math.sin(level * 0.6 + time) * r * 0.4 * audioFactor;
          const dist = r * (1 - level / levels) * (1 + Math.cos(time) * 0.3);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist + depth);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function drawHypercube(x, y, r, level, time) {
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + time * 1.1;
          const mod = Math.cos(level + time) * audioFactor;
          const dist = r * (0.6 + mod * 0.6);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
        }
        ctx.closePath();
        ctx.stroke();
      }

      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2 + timeFactor * modulation;
        const x = centerX + radius * Math.cos(angle) * audioFactor;
        const y = centerY + radius * Math.sin(angle) * audioFactor;
        drawRecursiveShape(x, y, radius * scaleFactor, 1);
      }
      console.log('Mandala generated');
    }

    function randomizeMandala() {
      document.getElementById('segments').value = Math.floor(Math.random() * 47) + 3;
      document.getElementById('levels').value = Math.floor(Math.random() * 14) + 1;
      document.getElementById('scaleFactor').value = (Math.random() * 0.6 + 0.3).toFixed(2);
      document.getElementById('initialRadius').value = Math.floor(Math.random() * 350) + 50;
      document.getElementById('lineWidth').value = (Math.random() * 9 + 1).toFixed(1);
      document.getElementById('baseFreq').value = Math.floor(Math.random() * 980) + 20;
      document.getElementById('freqMultiplier').value = (Math.random() * 2 + 1).toFixed(1);
      document.getElementById('waveform').value = ['sine', 'sawtooth', 'square', 'triangle'][Math.floor(Math.random() * 4)];
      document.getElementById('modulation').value = (Math.random() * 2.9 + 0.1).toFixed(1);
      document.getElementById('patternType').value = ['cymatic', 'vortex', 'nebula', 'chaos', 'flower', 'yantra', 'tunnel', 'hypercube'][Math.floor(Math.random() * 8)];
      document.getElementById('lineColor').value = randomColor();
      document.getElementById('secondaryColor').value = randomColor();
      updateValueDisplays();
      generateMandala();
    }

    function randomColor() {
      return '#' + Math.floor(Math.random() * 16777215).toString(16);
    }

    function downloadMandala() {
      const link = document.createElement('a');
      link.download = 'infinite-spiral.png';
      link.href = mandalaCanvas.toDataURL('image/png');
      link.click();
    }

    function toggleAnimation() {
      if (isAnimating) {
        cancelAnimationFrame(animationId);
        document.getElementById('animate').textContent = 'Pulse Cosmos';
        isAnimating = false;
      } else {
        document.getElementById('animate').textContent = 'Collapse Cosmos';
        isAnimating = true;
        requestAnimationFrame(animate);
      }
    }

    function animate() {
      const modulation = parseFloat(document.getElementById('modulation').value);
      const time = performance.now() * 0.001 * modulation;
      generateMandala(time);
      if (isAnimating) {
        animationId = requestAnimationFrame(animate);
      }
    }

    function openTab(evt, tabName) {
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById(tabName).classList.add('active');
      evt.currentTarget.classList.add('active');
    }

    window.onload = init;
  </script>
</body>
</html>

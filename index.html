<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR House Tour with Three.js</title>
    <script src="/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100vh;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 20px;
            z-index: 10;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 18px;
            background-color: #00ff00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
        #vrButton:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="instructions">
        <p>Instructions for Elderly Users:</p>
        <p>- Click "Enter VR" to start (Meta Quest).</p>
        <p>- Use thumbstick to move in VR.</p>
        <p>- Point and press trigger to select hotspots.</p>
        <p>- Click and drag (non-VR) to look around.</p>
        <p>- Click yellow hotspots to enter rooms.</p>
    </div>
    <button id="vrButton">Enter VR</button>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Enable WebXR
        renderer.xr.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(30, 30);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90ee90 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Function to create a room with walls and a door
        function createRoom(x, y, z, width, height, depth, color, doorSide = 'front') {
            const group = new THREE.Group();
            const wallMaterial = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(width, depth);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            group.add(floor);
            
            // Back wall
            const backWallGeometry = new THREE.PlaneGeometry(width, height);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, height / 2, depth / 2);
            backWall.rotation.y = Math.PI;
            group.add(backWall);
            
            // Left wall
            const leftWallGeometry = new THREE.PlaneGeometry(depth, height);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-width / 2, height / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            group.add(leftWall);
            
            // Right wall
            const rightWallGeometry = new THREE.PlaneGeometry(depth, height);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(width / 2, height / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            group.add(rightWall);
            
            // Front wall with door (fixed approach using separate wall segments)
            if (doorSide === 'front') {
                const doorWidth = width * 0.3;
                const doorHeight = height * 0.7;
                const doorPositionX = 0;
                
                // Top part of front wall
                const topWallGeometry = new THREE.PlaneGeometry(width, height - doorHeight);
                const topWall = new THREE.Mesh(topWallGeometry, wallMaterial);
                topWall.position.set(0, height - (height - doorHeight) / 2, -depth / 2);
                group.add(topWall);
                
                // Left part of front wall
                const leftDoorWallGeometry = new THREE.PlaneGeometry((width - doorWidth) / 2, doorHeight);
                const leftDoorWall = new THREE.Mesh(leftDoorWallGeometry, wallMaterial);
                leftDoorWall.position.set(-doorWidth / 2 - (width - doorWidth) / 4, doorHeight / 2, -depth / 2);
                group.add(leftDoorWall);
                
                // Right part of front wall
                const rightDoorWallGeometry = new THREE.PlaneGeometry((width - doorWidth) / 2, doorHeight);
                const rightDoorWall = new THREE.Mesh(rightDoorWallGeometry, wallMaterial);
                rightDoorWall.position.set(doorWidth / 2 + (width - doorWidth) / 4, doorHeight / 2, -depth / 2);
                group.add(rightDoorWall);
            } else {
                // No door, just a regular front wall
                const frontWallGeometry = new THREE.PlaneGeometry(width, height);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.set(0, height / 2, -depth / 2);
                group.add(frontWall);
            }
            
            group.position.set(x, y, z);
            return group;
        }

        // Ground Floor Structure
        const groundFloor = new THREE.Group();
        scene.add(groundFloor);

        const livingRoom = createRoom(-3, 0, 0, 4, 3, 3, 0xadd8e6, 'front');
        groundFloor.add(livingRoom);

        const kitchen = createRoom(2, 0, 0, 2, 3, 2, 0xf0e68c, 'front');
        groundFloor.add(kitchen);

        const bedroom1 = createRoom(-3, 0, -4, 2, 3, 2, 0xffb6c1, 'front');
        groundFloor.add(bedroom1);

        const bedroom2 = createRoom(0, 0, -4, 2, 3, 2, 0xffb6c1, 'front');
        groundFloor.add(bedroom2);

        const bathroom = createRoom(3, 0, -4, 1.5, 3, 1.5, 0x87cefa, 'front');
        groundFloor.add(bathroom);

        // First Floor Structure
        const firstFloor = new THREE.Group();
        scene.add(firstFloor);

        const bedroom3 = createRoom(-2, 3, 0, 2, 3, 2, 0xffb6c1, 'front');
        firstFloor.add(bedroom3);

        const bathroom2 = createRoom(1, 3, 0, 1.5, 3, 1.5, 0x87cefa, 'front');
        firstFloor.add(bathroom2);

        // Pool Area
        const poolGeometry = new THREE.BoxGeometry(5, 0.5, 10);
        const poolMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const pool = new THREE.Mesh(poolGeometry, poolMaterial);
        pool.position.set(0, 0.25, -12);
        scene.add(pool);

        // Hotspots
        const hotspotGeometry = new THREE.CircleGeometry(0.2, 32);
        const hotspotMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 0.5
        });

        // Function to create a hotspot
        function createHotspot(x, y, z, target, enterPos) {
            const hotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            hotspot.position.set(x, y, z);
            hotspot.rotation.x = -Math.PI / 2; // Make it face up
            hotspot.userData = { 
                target: target, 
                enterPos: enterPos,
                isHotspot: true // Flag for easy identification
            };
            scene.add(hotspot);
            return hotspot;
        }

        // Create all hotspots
        const livingRoomHotspot = createHotspot(-3, 0.1, -1.5, 'livingRoom', new THREE.Vector3(-3, 1.6, -0.5));
        const kitchenHotspot = createHotspot(2, 0.1, -1, 'kitchen', new THREE.Vector3(2, 1.6, -0.5));
        const backHotspot = createHotspot(0, 0.1, -5, 'main', new THREE.Vector3(0, 1.6, 5));
        backHotspot.visible = false;

        const bedroom1Hotspot = createHotspot(-3, 0.1, -4, 'bedroom1', new THREE.Vector3(-3, 1.6, -3));
        const bedroom2Hotspot = createHotspot(0, 0.1, -4, 'bedroom2', new THREE.Vector3(0, 1.6, -3));
        const bathroomHotspot = createHotspot(3, 0.1, -4, 'bathroom', new THREE.Vector3(3, 1.6, -3));
        const poolHotspot = createHotspot(0, 0.1, -9, 'pool', new THREE.Vector3(0, 1.6, -9));

        // Collection of all hotspots for raycasting
        const allHotspots = [
            livingRoomHotspot, kitchenHotspot, backHotspot, 
            bedroom1Hotspot, bedroom2Hotspot, bathroomHotspot, poolHotspot
        ];

        // Function to handle hotspot selection
        function selectHotspot(hotspot) {
            if (!hotspot || !hotspot.userData.isHotspot) return;
            
            const target = hotspot.userData.target;
            camera.position.copy(hotspot.userData.enterPos);
            
            // Toggle hotspot visibility based on location
            if (target === 'livingRoom' || target === 'kitchen') {
                livingRoomHotspot.visible = false;
                kitchenHotspot.visible = false;
                backHotspot.visible = true;
                backHotspot.position.set(hotspot.position.x, 0.1, hotspot.position.z + 1);
            } else if (target === 'main') {
                livingRoomHotspot.visible = true;
                kitchenHotspot.visible = true;
                backHotspot.visible = false;
            }
        }

        // Initial camera position
        camera.position.set(0, 1.6, 5);

        // Raycaster for clicking hotspots (non-VR mode)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Basic mouse controls for looking around (non-VR)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (isDragging && !renderer.xr.isPresenting) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            if (!renderer.xr.isPresenting) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(allHotspots);

                if (intersects.length > 0) {
                    selectHotspot(intersects[0].object);
                }
            }
        }

        window.addEventListener('mousedown', onMouseDown, false);
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseup', onMouseUp, false);

        // VR Button setup
        const vrButton = document.getElementById('vrButton');
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                vrButton.disabled = !supported;
                vrButton.textContent = supported ? 'Enter VR' : 'VR Not Supported';
            });

            vrButton.addEventListener('click', () => {
                if (!renderer.xr.isPresenting) {
                    renderer.xr.enabled = true;
                    navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor', 'bounded-floor']
                    }).then((session) => {
                        renderer.xr.setSession(session);
                        vrButton.textContent = 'Exit VR';
                        
                        session.addEventListener('end', () => {
                            vrButton.textContent = 'Enter VR';
                        });
                    });
                } else {
                    renderer.xr.getSession().end();
                }
            });
        } else {
            vrButton.disabled = true;
            vrButton.textContent = 'VR Not Supported';
        }

        // Controller setup for VR
        let controller1, controller2;
        
        function setupVRControllers() {
            // Controller 1 for interaction
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            
            // Controller 2 for movement (second hand)
            controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            
            // Visualize controllers with simple objects
            const controllerGeometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08, 16);
            controllerGeometry.rotateX(-Math.PI / 2);
            const controllerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            
            const controllerMesh1 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controllerMesh1.position.set(0, 0, -0.05);
            controller1.add(controllerMesh1);
            
            const controllerMesh2 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controllerMesh2.position.set(0, 0, -0.05);
            controller2.add(controllerMesh2);
            
            // Add raycaster line for visual feedback
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -5)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            controller1.add(line);
        }
        
        setupVRControllers();
        
        // VR controller interaction
        const tempMatrix = new THREE.Matrix4();
        const vrRaycaster = new THREE.Raycaster();
        
        function onSelectStart(event) {
            const controller = event.target;
            
            // Get controller position and direction
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            vrRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            vrRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            // Check for intersections with hotspots
            const intersects = vrRaycaster.intersectObjects(allHotspots);
            
            if (intersects.length > 0) {
                selectHotspot(intersects[0].object);
            }
        }
        
        function onSelectEnd() {
            // Optional: Add visual feedback when selection ends
        }

        // Movement variables
        const moveSpeed = 0.05;
        let moveDirection = new THREE.Vector3();
        
        // Animation loop with controller movement
        function animate() {
            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    // Handle VR movement via controllers
                    if (controller2) {
                        const gamepad = navigator.getGamepads().find(gp => 
                            gp && gp.id && gp.id.includes('Oculus Touch') && 
                            gp.index === controller2.userData.gamepadIndex
                        );
                        
                        if (gamepad && gamepad.axes.length >= 4) {
                            const thumbstickX = gamepad.axes[2]; // Right thumbstick X-axis (Meta Quest)
                            const thumbstickY = gamepad.axes[3]; // Right thumbstick Y-axis
                            
                            if (Math.abs(thumbstickX) > 0.1 || Math.abs(thumbstickY) > 0.1) {
                                moveDirection.set(thumbstickX, 0, thumbstickY).normalize();
                                
                                // Get camera direction for movement relative to view
                                const xrCamera = renderer.xr.getCamera(camera);
                                const cameraDirection = new THREE.Vector3();
                                xrCamera.getWorldDirection(cameraDirection);
                                cameraDirection.y = 0; // Keep movement horizontal
                                cameraDirection.normalize();
                                
                                // Calculate movement vector
                                const moveVector = new THREE.Vector3();
                                moveVector.addScaledVector(cameraDirection, -thumbstickY * moveSpeed);
                                moveVector.addScaledVector(
                                    new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection),
                                    thumbstickX * moveSpeed
                                );
                                
                                // Apply movement
                                camera.position.add(moveVector);
                                camera.position.y = 1.6; // Lock height to eye level
                            }
                        }
                    }
                    
                    // Visual feedback for VR interaction
                    if (controller1) {
                        tempMatrix.identity().extractRotation(controller1.matrixWorld);
                        vrRaycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
                        vrRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                        
                        const intersects = vrRaycaster.intersectObjects(allHotspots);
                        
                        // Update controller line color based on intersection
                        const line = controller1.children.find(child => child instanceof THREE.Line);
                        if (line) {
                            line.material.color.set(intersects.length > 0 ? 0x00ff00 : 0xff0000);
                        }
                    }
                }
                
                renderer.render(scene, camera);
            });
        }
        
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Store gamepad index when controller connects
        function handleControllerConnected(event, controllerIndex) {
            event.target.userData.gamepadIndex = event.data.gamepad.index;
        }
        
        if (controller1) {
            controller1.addEventListener('connected', (event) => handleControllerConnected(event, 0));
        }
        
        if (controller2) {
            controller2.addEventListener('connected', (event) => handleControllerConnected(event, 1));
        }
    </script>
</body>
</html>


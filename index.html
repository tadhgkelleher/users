<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR House Tour with Three.js</title>
    <script src="/scripts/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100vh;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 20px;
            z-index: 10;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 18px;
            background-color: #00ff00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
        #vrButton:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="instructions">
        <p>Instructions for Elderly Users:</p>
        <p>- Click "Enter VR" to start (Meta Quest).</p>
        <p>- Use thumbstick to move in VR.</p>
        <p>- Click and drag (non-VR) to look around.</p>
        <p>- Click yellow hotspots to enter rooms.</p>
    </div>
    <button id="vrButton">Enter VR</button>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Enable WebXR
        renderer.xr.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(30, 30);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x90ee90 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Function to create a room with walls and a door
        function createRoom(x, y, z, width, height, depth, color, doorSide = 'front') {
            const group = new THREE.Group();

            const wallMaterial = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide });
            const wallThickness = 0.1;

            const frontWallGeometry = new THREE.PlaneGeometry(width, height);
            const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            frontWall.position.set(0, height / 2, -depth / 2);
            if (doorSide === 'front') {
                const doorWidth = width * 0.3;
                const doorHeight = height * 0.6;
                const doorShape = new THREE.Shape();
                doorShape.moveTo(-doorWidth / 2, 0);
                doorShape.lineTo(-doorWidth / 2, doorHeight);
                doorShape.lineTo(doorWidth / 2, doorHeight);
                doorShape.lineTo(doorWidth / 2, 0);
                const hole = new THREE.Path();
                hole.fromPoints(doorShape.getPoints());
                frontWallGeometry.holes = [hole];
                frontWallGeometry.verticesNeedUpdate = true;
            }
            group.add(frontWall);

            const backWallGeometry = new THREE.PlaneGeometry(width, height);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, height / 2, depth / 2);
            backWall.rotation.y = Math.PI;
            group.add(backWall);

            const leftWallGeometry = new THREE.PlaneGeometry(depth, height);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-width / 2, height / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            group.add(leftWall);

            const rightWallGeometry = new THREE.PlaneGeometry(depth, height);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(width / 2, height / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            group.add(rightWall);

            const floorGeometry = new THREE.PlaneGeometry(width, depth);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            group.add(floor);

            group.position.set(x, y, z);
            return group;
        }

        // Ground Floor Structure
        const groundFloor = new THREE.Group();
        scene.add(groundFloor);

        const livingRoom = createRoom(-3, 0, 0, 4, 3, 3, 0xadd8e6, 'front');
        groundFloor.add(livingRoom);

        const kitchen = createRoom(2, 0, 0, 2, 3, 2, 0xf0e68c, 'front');
        groundFloor.add(kitchen);

        const bedroom1 = createRoom(-3, 0, -4, 2, 3, 2, 0xffb6c1, 'front');
        groundFloor.add(bedroom1);

        const bedroom2 = createRoom(0, 0, -4, 2, 3, 2, 0xffb6c1, 'front');
        groundFloor.add(bedroom2);

        const bathroom = createRoom(3, 0, -4, 1.5, 3, 1.5, 0x87cefa, 'front');
        groundFloor.add(bathroom);

        // First Floor Structure
        const firstFloor = new THREE.Group();
        scene.add(firstFloor);

        const bedroom3 = createRoom(-2, 3, 0, 2, 3, 2, 0xffb6c1, 'front');
        firstFloor.add(bedroom3);

        const bathroom2 = createRoom(1, 3, 0, 1.5, 3, 1.5, 0x87cefa, 'front');
        firstFloor.add(bathroom2);

        // Pool Area
        const poolGeometry = new THREE.BoxGeometry(5, 0.5, 10);
        const poolMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const pool = new THREE.Mesh(poolGeometry, poolMaterial);
        pool.position.set(0, 0.25, -12);
        scene.add(pool);

        // Hotspots
        const hotspotGeometry = new THREE.CircleGeometry(0.2, 32);
        const hotspotMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        const livingRoomHotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
        livingRoomHotspot.position.set(-3, 0.1, -1.5);
        livingRoomHotspot.userData = { target: 'livingRoom', enterPos: new THREE.Vector3(-3, 1.6, -0.5) };
        scene.add(livingRoomHotspot);

        const kitchenHotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
        kitchenHotspot.position.set(2, 0.1, -1);
        kitchenHotspot.userData = { target: 'kitchen', enterPos: new THREE.Vector3(2, 1.6, -0.5) };
        scene.add(kitchenHotspot);

        const backHotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
        backHotspot.position.set(0, 0.1, -5);
        backHotspot.userData = { target: 'main', enterPos: new THREE.Vector3(0, 2, 5) };
        backHotspot.visible = false;
        scene.add(backHotspot);

        // Initial camera position
        camera.position.set(0, 2, 5);

        // Raycaster for clicking hotspots (non-VR mode)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Basic mouse controls for looking around (non-VR)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (isDragging && !renderer.xr.isPresenting) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            if (!renderer.xr.isPresenting) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([livingRoomHotspot, kitchenHotspot, backHotspot]);

                if (intersects.length > 0) {
                    const hotspot = intersects[0].object;
                    const target = hotspot.userData.target;
                    camera.position.copy(hotspot.userData.enterPos);
                    if (target === 'livingRoom' || target === 'kitchen') {
                        livingRoomHotspot.visible = false;
                        kitchenHotspot.visible = false;
                        backHotspot.visible = true;
                        backHotspot.position.set(hotspot.position.x, 0.1, hotspot.position.z + 1);
                    } else if (target === 'main') {
                        livingRoomHotspot.visible = true;
                        kitchenHotspot.visible = true;
                        backHotspot.visible = false;
                    }
                }
            }
        }

        window.addEventListener('mousedown', onMouseDown, false);
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseup', onMouseUp, false);

        // VR Button setup
        const vrButton = document.getElementById('vrButton');
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                vrButton.disabled = !supported;
                vrButton.textContent = supported ? 'Enter VR' : 'VR Not Supported';
            });

            vrButton.addEventListener('click', () => {
                if (!renderer.xr.isPresenting) {
                    renderer.xr.enabled = true;
                    navigator.xr.requestSession('immersive-vr').then((session) => {
                        renderer.xr.setSession(session);
                        vrButton.textContent = 'Exit VR';
                    });
                } else {
                    renderer.xr.getSession().end();
                    vrButton.textContent = 'Enter VR';
                }
            });
        } else {
            vrButton.disabled = true;
            vrButton.textContent = 'VR Not Supported';
        }

        // Controller setup for Meta Quest
        const controller = renderer.xr.getController(0);
        scene.add(controller);

        // Movement variables
        const moveSpeed = 0.05;
        let moveDirection = new THREE.Vector3();

        controller.addEventListener('selectstart', () => {
            // Optional: Add interaction with hotspots in VR if needed
        });

        // Animation loop with controller movement
        function animate() {
            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    const xrCamera = renderer.xr.getCamera(camera);
                    const gamepad = navigator.getGamepads()[controller.userData.gamepadIndex];

                    if (gamepad && gamepad.axes.length >= 2) {
                        const thumbstickX = gamepad.axes[2]; // Right thumbstick X-axis (Meta Quest)
                        const thumbstickY = gamepad.axes[3]; // Right thumbstick Y-axis

                        moveDirection.set(thumbstickX, 0, thumbstickY).normalize();
                        const cameraDirection = new THREE.Vector3();
                        xrCamera.getWorldDirection(cameraDirection);
                        cameraDirection.y = 0; // Keep movement horizontal
                        cameraDirection.normalize();

                        const moveVector = cameraDirection.multiplyScalar(-thumbstickY * moveSpeed)
                            .add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection).multiplyScalar(thumbstickX * moveSpeed));

                        camera.position.add(moveVector);
                        camera.position.y = 1.6; // Lock height to eye level
                    }
                }

                renderer.render(scene, camera);
            });
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Store gamepad index when controller connects
        controller.addEventListener('connected', (event) => {
            controller.userData.gamepadIndex = event.data.gamepad.index;
        });
    </script>
</body>
</html>

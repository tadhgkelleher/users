<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spiritual Machine: Infinite Spiral Weaver</title>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c);
      color: #e0e0ff;
      margin: 0;
      padding: 20px;
      overflow: hidden;
      animation: voidShift 20s infinite alternate;
    }

    @keyframes voidShift {
      0% { background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c); }
      50% { background: radial-gradient(circle, #ff00ff, #00ffff, #ff6ec7); }
      100% { background: radial-gradient(circle, #1a3b5c, #5c2a7d, #ff4500); }
    }

    h1 {
      font-size: 3.5rem;
      color: #00ffff;
      text-shadow: 0 0 20px #ff6ec7, 0 0 40px #9b59b6, 0 0 60px #00ffff;
      animation: resonate 1.5s infinite alternate;
      margin-bottom: 30px;
    }

    @keyframes resonate {
      0% { text-shadow: 0 0 15px #ff6ec7, 0 0 30px #9b59b6; }
      100% { text-shadow: 0 0 30px #00ffff, 0 0 60px #ff4500; }
    }

    canvas {
      border: 4px solid #ff00ff;
      border-radius: 20px;
      background: #0a0a1f;
      box-shadow: 0 0 70px rgba(255, 0, 255, 0.8), inset 0 0 30px rgba(0, 0, 0, 0.9);
      transition: transform 0.3s, box-shadow 0.3s;
      max-width: 100%;
    }

    canvas:hover {
      transform: scale(1.05);
      box-shadow: 0 0 100px rgba(0, 255, 255, 0.9);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 25px;
      background: rgba(10, 10, 40, 0.9);
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.6);
      margin-bottom: 25px;
      border: 2px solid #00ffff;
    }

    button {
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      padding: 12px 25px;
      border: none;
      border-radius: 10px;
      color: #1a1a3b;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.4s;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
      text-shadow: 0 0 5px #ffffff;
    }

    button:hover {
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 1);
    }

    .parameter_input {
      position: relative;
      padding: 15px;
    }

    .tooltip {
      background: rgba(10, 10, 40, 0.95);
      color: #00ffff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 0 10px #ff00ff;
    }

    .parameter_input:hover .tooltip {
      opacity: 1;
    }

    .particle-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
  </style>
</head>
<body>
  <h1>Spiritual Machine: Infinite Spiral Weaver</h1>

  <div class="controls">
    <button id="generate">Weave Infinity</button>
    <button id="random">Rift Chaos</button>
    <button id="animate">Pulse Cosmos</button>
    <button id="download">Capture Eternity</button>
    <button id="enterVR">Dive into VR</button>
  </div>

  <div class="parameter_input">
    <span class="tooltip">Quantum Flux</span>
    <label for="modulation">Flux</label>
    <input type="range" id="modulation" value="0.5" min="0" max="5" step="0.1" oninput="updateValue('modulation')">
    <span id="modulation-value">0.5</span>
  </div>

  <canvas id="mandalaCanvas" width="800" height="800"></canvas>
  <canvas id="particleCanvas" class="particle-layer" width="800" height="800"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js" onload="initThreeLoaded = true" onerror="console.error('Failed to load Three.js')"></script>
  <script>
    // Core Variables
    const canvas = document.getElementById('mandalaCanvas');
    const ctx = canvas.getContext('2d');
    const particleCanvas = document.getElementById('particleCanvas');
    const particleCtx = particleCanvas.getContext('2d');
    let animationId = null;
    let isAnimating = false;
    let particles = [];
    let audioContext, analyser;
    let scene, camera, renderer, spiralTunnel;
    let initThreeLoaded = false;

    // Audio Initialization
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;

        const osc = audioContext.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 432; // Heart chakra vibe
        const gain = audioContext.createGain();
        gain.gain.value = 0.1;
        osc.connect(gain).connect(analyser).connect(audioContext.destination);
        osc.start();
      }
    }

    function getAudioFactor() {
      if (!analyser) return 1;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
      return 1 + (avg / 255) * 2;
    }

    // Particle System
    class Particle {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.z = Math.random() * 100 - 50;
        this.size = Math.random() * 8 + 2;
        this.speedX = Math.random() * 3 - 1.5;
        this.speedY = Math.random() * 3 - 1.5;
        this.speedZ = Math.random() * 2 - 1;
        this.life = Math.random() * 150;
      }

      update(audioFactor) {
        this.x += this.speedX * audioFactor;
        this.y += this.speedY * audioFactor;
        this.z += this.speedZ * audioFactor;
        this.life -= 1.5;
        if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
        if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
        if (this.z < -50 || this.z > 50) this.speedZ *= -1;
      }

      draw(audioFactor) {
        const perspective = 50 / (50 + this.z);
        const radius = Math.max(this.size * perspective * audioFactor, 0);
        particleCtx.fillStyle = `rgba(0, 255, 255, ${this.life / 150 * audioFactor})`;
        particleCtx.beginPath();
        particleCtx.arc(this.x, this.y, radius, 0, Math.PI * 2);
        particleCtx.fill();
      }
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < 100; i++) {
        particles.push(new Particle());
      }
    }

    function animateParticles(audioFactor) {
      particleCtx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach((p, i) => {
        p.update(audioFactor);
        p.draw(audioFactor);
        if (p.life <= 0) particles.splice(i, 1);
      });
      while (particles.length < 100) particles.push(new Particle());
    }

    // VR Setup with Sine-Wave Spiral Tunnel
    function initVR() {
      if (!window.THREE) {
        console.error('Three.js not loaded. VR unavailable.');
        document.getElementById('enterVR').textContent = 'VR Unavailable';
        document.getElementById('enterVR').disabled = true;
        return;
      }

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.xr.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);

      const vertexShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        uniform float audioFactor;
        void main() {
          vUv = uv;
          vPosition = position;
          vec3 pos = position;
          float spiral = sin(pos.z * 5.0 + time) * cos(pos.z * 3.0 + time) * audioFactor;
          pos.x += spiral * 2.0;
          pos.y += spiral * 2.0;
          pos.z += sin(time + pos.x) * audioFactor;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;
      const fragmentShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        uniform float audioFactor;
        uniform vec3 color1;
        uniform vec3 color2;
        void main() {
          float pulse = sin(vUv.x * 20.0 + time * 2.0) * cos(vUv.y * 15.0 + time) * audioFactor;
          vec3 color = mix(color1, color2, abs(pulse));
          float glow = 1.0 + sin(time + vPosition.z * 5.0) * audioFactor;
          gl_FragColor = vec4(color * glow, 1.0);
        }
      `;

      const points = [];
      for (let z = -50; z < 50; z += 0.5) {
        const angle = z * 0.2;
        const radius = 5 + Math.sin(z * 0.5) * 2;
        points.push(new THREE.Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          z
        ));
      }
      const geometry = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 200, 5, 32, true);
      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          time: { value: 0 },
          audioFactor: { value: 1 },
          color1: { value: new THREE.Color('#ff00ff') },
          color2: { value: new THREE.Color('#00ffff') }
        },
        side: THREE.DoubleSide,
        transparent: true
      });
      spiralTunnel = new THREE.Mesh(geometry, material);
      scene.add(spiralTunnel);
      camera.position.z = -10;

      document.getElementById('enterVR').addEventListener('click', async () => {
        if (!navigator.xr) {
          console.error('WebXR not supported');
          alert('VR not supported in this browser.');
          return;
        }
        try {
          const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor'] });
          renderer.xr.setSession(session);
          renderer.setAnimationLoop(animateVR);
          console.log('VR session started');
        } catch (err) {
          console.error('Failed to start VR:', err);
          alert('Failed to enter VR: ' + err.message);
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animateVR() {
      const audioFactor = getAudioFactor();
      const time = performance.now() * 0.001;
      spiralTunnel.material.uniforms.time.value = time;
      spiralTunnel.material.uniforms.audioFactor.value = audioFactor;
      spiralTunnel.material.uniforms.color1.value.setStyle('#ff00ff');
      spiralTunnel.material.uniforms.color2.value.setStyle('#00ffff');
      spiralTunnel.rotation.z += 0.01 * audioFactor;
      camera.position.z += 0.1 * audioFactor;
      if (camera.position.z > 50) camera.position.z = -50;
      renderer.render(scene, camera);
    }

    // Core Functions
    function init() {
      document.getElementById('generate').addEventListener('click', generateMandala);
      document.getElementById('random').addEventListener('click', randomizeMandala);
      document.getElementById('download').addEventListener('click', downloadMandala);
      document.getElementById('animate').addEventListener('click', toggleAnimation);
      updateValueDisplays();
      initAudio();
      initParticles();
      if (initThreeLoaded) {
        initVR();
      } else {
        const checkThree = setInterval(() => {
          if (initThreeLoaded) {
            initVR();
            clearInterval(checkThree);
          }
        }, 100);
      }
      generateMandala();
    }

    function updateValueDisplays() {
      document.getElementById('modulation-value').textContent = document.getElementById('modulation').value;
    }

    function updateValue(id) {
      updateValueDisplays();
      if (!isAnimating) generateMandala();
    }

    function generateMandala(timeFactor = 0) {
      const modulation = parseFloat(document.getElementById('modulation').value);
      const radius = 150;
      const segments = 12;
      const audioFactor = getAudioFactor();

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      ctx.lineWidth = 2 * audioFactor;
      ctx.strokeStyle = `hsl(${timeFactor * 50 % 360}, 100%, 50%)`;
      ctx.shadowBlur = 30;
      ctx.shadowColor = '#ff00ff';

      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2 + timeFactor * 0.3;
        const x = centerX + radius * Math.cos(angle) * audioFactor;
        const y = centerY + radius * Math.sin(angle) * audioFactor;
        ctx.beginPath();
        for (let j = 0; j < 360; j++) {
          const theta = (j / 360) * Math.PI * 2;
          const r = radius * Math.sin(theta * 5 + timeFactor * modulation) * audioFactor;
          ctx.lineTo(x + r * Math.cos(theta), y + r * Math.sin(theta));
        }
        ctx.closePath();
        ctx.stroke();
      }
    }

    function randomizeMandala() {
      document.getElementById('modulation').value = (Math.random() * 5).toFixed(1);
      updateValueDisplays();
      generateMandala();
    }

    function downloadMandala() {
      const link = document.createElement('a');
      link.download = 'infinite-spiral.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function toggleAnimation() {
      if (isAnimating) {
        cancelAnimationFrame(animationId);
        document.getElementById('animate').textContent = 'Pulse Cosmos';
        isAnimating = false;
      } else {
        document.getElementById('animate').textContent = 'Collapse Cosmos';
        isAnimating = true;
        requestAnimationFrame(animate);
      }
    }

    function animate() {
      const modulation = parseFloat(document.getElementById('modulation').value);
      const audioFactor = getAudioFactor();
      const time = performance.now() * 0.001 * modulation;

      generateMandala(time);
      animateParticles(audioFactor);

      if (isAnimating) {
        animationId = requestAnimationFrame(animate);
      }
    }

    window.onload = init;
  </script>
</body>
</html>

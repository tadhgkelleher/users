<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Weaver: Voice of the Void - Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c);
            color: #e0e0ff;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            animation: nebulaFlow 30s infinite alternate;
        }

        @keyframes nebulaFlow {
            0% { background: radial-gradient(circle, #0a0a1f, #1a1a3b, #2a2a5c); }
            33% { background: radial-gradient(circle, #ff00ff, #00ffff, #9b59b6); }
            66% { background: radial-gradient(circle, #ff4500, #1a3b5c, #ff6ec7); }
            100% { background: radial-gradient(circle, #2a2a5c, #9b59b6, #0a0a1f); }
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: #00ffff;
            text-shadow: 0 0 30px #ff6ec7, 0 0 60px #9b59b6, 0 0 90px #ff4500;
            animation: mantraGlow 3s infinite alternate;
            margin: 20px 0;
        }

        @keyframes mantraGlow {
            0% { text-shadow: 0 0 20px #ff6ec7, 0 0 40px #9b59b6; }
            100% { text-shadow: 0 0 40px #00ffff, 0 0 80px #ff4500; }
        }

        #mandalaCanvas {
            border: 6px solid #ff00ff;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(10, 10, 31, 0.9), rgba(26, 26, 59, 0.4));
            box-shadow: 0 0 100px rgba(255, 0, 255, 0.9), inset 0 0 50px rgba(0, 255, 255, 0.5);
            max-width: 90vw;
            max-height: 90vh;
            display: block;
            margin: 20px auto;
            transition: transform 0.5s ease, box-shadow 0.5s ease;
        }

        #mandalaCanvas:hover {
            transform: scale(1.1) rotate(2deg);
            box-shadow: 0 0 150px rgba(0, 255, 255, 1);
        }

        #vrCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: none;
        }

        #gameInfo {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #ff00ff;
            font-size: 1.2rem;
        }

        #progressBar {
            position: fixed;
            top: 60px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #00ffff;
            border-radius: 5px;
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            transition: width 0.3s ease;
        }

        #soundMeter {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #00ffff;
            border-radius: 5px;
        }

        #soundBar {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            transition: width 0.1s ease;
        }

        #soundInfo {
            position: fixed;
            bottom: 50px;
            left: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .controls {
            margin: 20px;
        }

        button {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            color: #1a1a3b;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.4s;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.9);
            margin: 5px;
        }

        button:hover {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 1);
        }
    </style>
</head>

<body>
    <h1>Cosmic Weaver: Voice of the Void - Game</h1>

    <div id="gameInfo">Level: 1 | Score: 0 | Target: 0 Hz</div>
    <div id="progressBar">
        <div id="progressFill" style="width: 0%;"></div>
    </div>

    <div class="controls">
        <button id="startGame">Start Game</button>
        <button id="drone">Toggle Drone</button>
        <button id="download">Capture Void</button>
        <button id="enterVR">Enter Temple</button>
    </div>

    <div id="soundMeter">
        <div id="soundBar" style="width: 0%;"></div>
    </div>
    <div id="soundInfo">Amplitude: 0% | Pitch: 0 Hz</div>

    <canvas id="mandalaCanvas" width="800" height="800"></canvas>
    <canvas id="vrCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const mandalaCanvas = document.getElementById('mandalaCanvas');
        const ctx = mandalaCanvas.getContext('2d');
        const vrCanvas = document.getElementById('vrCanvas');
        let animationId = null;
        let audioContext, droneOscillator, droneGain, voiceAnalyser;
        let scene, camera, renderer, mandalaPlane, orbs = [];
        let voicePitch = 0;
        let voiceAmplitude = 0;
        let droneAmplitude = 0;
        let rotationSpeed = 0;
        let timeFactor = 0;
        let needsRedraw = true;
        let lastUpdate = 0;

        // Game State
        let score = 0;
        let level = 1;
        let targetPitch = 0;
        let targetAmplitude = 0.3;
        let sustainTime = 0;
        let requiredSustain = 2000;
        const LEVEL_SCORE_THRESHOLD = 1000;
        const levels = [
            { preset: 'mandala', targetPitch: 110, targetAmplitude: 0.3, pitchTolerance: 20, sustain: 2000 },
            { preset: 'yantra', targetPitch: 136.1, targetAmplitude: 0.4, pitchTolerance: 15, sustain: 3000 },
            { preset: 'sufi', targetPitch: 174, targetAmplitude: 0.5, pitchTolerance: 12, sustain: 4000 },
            { preset: 'zen', targetPitch: 220, targetAmplitude: 0.6, pitchTolerance: 10, sustain: 5000 },
            { preset: 'mandelbrot', targetPitch: 432, targetAmplitude: 0.7, pitchTolerance: 8, sustain: 6000 },
            { preset: 'pi', targetPitch: 314, targetAmplitude: 0.8, pitchTolerance: 6, sustain: 7000 },
            { preset: 'schumann', targetPitch: 7.83, targetAmplitude: 0.9, pitchTolerance: 5, sustain: 8000 },
            { preset: 'floweroflife', targetPitch: 528, targetAmplitude: 1.0, pitchTolerance: 4, sustain: 9000 },
            { preset: 'e8', targetPitch: 639, targetAmplitude: 1.0, pitchTolerance: 3, sustain: 10000 }
        ];

        const defaultParams = {
            segments: 3,
            levels: 4,
            scaleFactor: 0.7,
            initialRadius: 200,
            lineColor: '#ff00ff',
            lineWidth: 3,
            baseFreq: 110,
            waveform: 'sine',
            secondaryColor: '#00ffff',
            modulation: 1,
            patternType: 'cymatic'
        };

        const params = { ...defaultParams };
        const IDLE_THRESHOLD = 0.05;
        const INTERPOLATION_SPEED = 0.05;

        // Audio Initialization
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('AudioContext initialized');
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => console.log('AudioContext resumed'));
            }
        }

        // Drone Control
        function toggleDrone() {
            initAudio();
            if (droneOscillator) {
                droneOscillator.stop();
                droneOscillator = null;
                droneGain = null;
                droneAmplitude = 0;
                document.getElementById('drone').textContent = 'Start Drone';
            } else {
                droneOscillator = audioContext.createOscillator();
                droneGain = audioContext.createGain();
                droneOscillator.type = params.waveform;
                droneOscillator.frequency.value = params.baseFreq;
                droneGain.gain.value = 0.1;
                droneAmplitude = 0.1;
                droneOscillator.connect(droneGain).connect(audioContext.destination);
                droneOscillator.start();
                document.getElementById('drone').textContent = 'Stop Drone';
                updateDroneParams();
            }
            needsRedraw = true;
        }

        function updateDroneParams() {
            if (droneOscillator) {
                rotationSpeed = Math.min(0.05, droneAmplitude * 0.5);
                timeFactor += droneAmplitude * 0.01;
                requestAnimationFrame(updateDroneParams);
            } else {
                rotationSpeed = 0;
            }
        }

        // Voice Detection
        function initVoiceControl() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    initAudio();
                    const source = audioContext.createMediaStreamSource(stream);
                    voiceAnalyser = audioContext.createAnalyser();
                    voiceAnalyser.fftSize = 2048;
                    voiceAnalyser.smoothingTimeConstant = 0.7;
                    source.connect(voiceAnalyser);
                    console.log('Voice analyser initialized');

                    const bufferLength = voiceAnalyser.fftSize;
                    const dataArray = new Float32Array(bufferLength);
                    const pitchHistory = [];

                    function detectPitch() {
                        voiceAnalyser.getFloatTimeDomainData(dataArray);
                        const pitch = autoCorrelate(dataArray, audioContext.sampleRate);
                        voiceAmplitude = getAmplitude(dataArray);

                        if (pitch !== -1 && pitch > 20 && pitch < 2000) {
                            pitchHistory.push(pitch);
                            if (pitchHistory.length > 3) pitchHistory.shift();
                            voicePitch = pitchHistory.reduce((a, b) => a + b) / pitchHistory.length;
                        } else {
                            voicePitch *= 0.95;
                        }

                        updateGameState();
                        updateSoundMeter();
                        requestAnimationFrame(detectPitch);
                    }
                    detectPitch();
                })
                .catch(e => console.error('Voice control failed:', e));
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.01) return -1;

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++)
                if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++)
                if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++)
                for (let j = 0; j < SIZE - i; j++)
                    c[i] += buf[j] * buf[j + i];

            let d = 0;
            while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) {
                    maxval = c[i];
                    maxpos = i;
                }
            }
            let T0 = maxpos;

            let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            let a = (x1 + x3 - 2 * x2) / 2;
            let b = (x3 - x1) / 2;
            if (a) T0 -= b / (2 * a);

            return sampleRate / T0;
        }

        function getAmplitude(buf) {
            let sum = 0;
            for (let i = 0; i < buf.length; i++) sum += Math.abs(buf[i]);
            return Math.min(1, sum / buf.length / 0.3);
        }

        function interpolateValue(current, target, speed) {
            return current + (target - current) * speed;
        }

        // Game Logic
        function updateGameState() {
            const currentLevel = levels[level - 1];
            targetPitch = currentLevel.targetPitch;
            targetAmplitude = currentLevel.targetAmplitude;
            requiredSustain = currentLevel.sustain;
            const pitchTolerance = currentLevel.pitchTolerance;

            if (voiceAmplitude > IDLE_THRESHOLD) {
                const pitchError = Math.abs(voicePitch - targetPitch);
                if (pitchError < pitchTolerance && voiceAmplitude >= targetAmplitude) {
                    sustainTime += 16;
                    const points = Math.floor((1 - pitchError / pitchTolerance) * 10 + voiceAmplitude * 10);
                    score += points;
                    params.segments = Math.min(30, params.segments + voiceAmplitude * 0.5);
                    params.initialRadius = Math.min(400, params.initialRadius + voicePitch * 0.05);
                    params.modulation = 1 + voiceAmplitude * 0.5;

                    if (sustainTime >= requiredSustain && score >= level * LEVEL_SCORE_THRESHOLD) {
                        advanceLevel();
                    }
                } else {
                    sustainTime = Math.max(0, sustainTime - 32);
                    score = Math.max(0, score - 5);
                }
            } else {
                sustainTime = Math.max(0, sustainTime - 16);
                params.segments = interpolateValue(params.segments, defaultParams.segments, INTERPOLATION_SPEED);
                params.initialRadius = interpolateValue(params.initialRadius, defaultParams.initialRadius, INTERPOLATION_SPEED);
                params.modulation = interpolateValue(params.modulation, defaultParams.modulation, INTERPOLATION_SPEED);
                timeFactor = interpolateValue(timeFactor, 0, INTERPOLATION_SPEED);
            }

            updateUI();
            needsRedraw = true;
        }

        function advanceLevel() {
            if (level < levels.length) {
                level++;
                sustainTime = 0;
                applyPreset(levels[level - 1].preset);
                console.log(`Advanced to Level ${level}`);
            } else {
                alert('Congratulations! You’ve mastered all levels!');
                resetGame();
            }
        }

        function resetGame() {
            score = 0;
            level = 1;
            sustainTime = 0;
            applyPreset(levels[0].preset);
            orbs.forEach(orb => scene && scene.remove(orb));
            orbs = [];
            needsRedraw = true;
        }

        function updateUI() {
            document.getElementById('gameInfo').textContent = `Level: ${level} | Score: ${score} | Target: ${Math.round(targetPitch)} Hz`;
            const progress = Math.min(100, (score / (level * LEVEL_SCORE_THRESHOLD)) * 100);
            document.getElementById('progressFill').style.width = `${progress}%`;
            const amplitudePercent = Math.round(voiceAmplitude * 100);
            document.getElementById('soundBar').style.width = `${amplitudePercent}%`;
            document.getElementById('soundInfo').textContent = `Amplitude: ${amplitudePercent}% | Pitch: ${Math.round(voicePitch)} Hz`;
        }

        // VR Initialization
        function initVR() {
            if (!window.THREE) {
                console.error('Three.js not loaded');
                document.getElementById('enterVR').textContent = 'VR Unavailable';
                return;
            }
            if (!navigator.xr) {
                console.warn('WebXR not supported');
                document.getElementById('enterVR').textContent = 'VR Not Supported';
                document.getElementById('enterVR').disabled = true;
                return;
            }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: vrCanvas, antialias: true });
            renderer.xr.enabled = true;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            const texture = new THREE.CanvasTexture(mandalaCanvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            const geometry = new THREE.PlaneGeometry(12, 12, 256, 256);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide, 
                transparent: true 
            });
            mandalaPlane = new THREE.Mesh(geometry, material);
            mandalaPlane.position.z = -8;
            scene.add(mandalaPlane);

            camera.position.z = 0;

            document.getElementById('enterVR').addEventListener('click', async () => {
                initAudio();
                await audioContext.resume();

                try {
                    const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor'] });
                    session.addEventListener('end', () => {
                        vrCanvas.style.display = 'none';
                        renderer.setAnimationLoop(null);
                        document.getElementById('enterVR').textContent = 'Enter Temple';
                        orbs.forEach(orb => scene.remove(orb));
                        orbs = [];
                    });

                    renderer.xr.setSession(session);
                    renderer.setAnimationLoop(() => {
                        needsRedraw = true;
                        animateVR();
                    });

                    vrCanvas.style.display = 'block';
                    document.getElementById('enterVR').textContent = 'Singing in VR';
                } catch (err) {
                    console.error('VR Failed:', err);
                    document.getElementById('enterVR').textContent = 'VR Failed';
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // VR Animation
        function animateVR() {
            mandalaPlane.material.map.needsUpdate = true;
            mandalaPlane.rotation.z += rotationSpeed;

            if (voiceAmplitude > IDLE_THRESHOLD) {
                const spawnCount = Math.floor(voiceAmplitude * 5);
                for (let i = 0; i < spawnCount; i++) {
                    if (Math.random() < voiceAmplitude * 0.3) {
                        const size = 0.05 + Math.random() * 0.15;
                        const orbGeometry = new THREE.SphereGeometry(size, 16, 16);
                        const orbMaterial = new THREE.MeshBasicMaterial({ 
                            color: new THREE.Color(params.secondaryColor), 
                            transparent: true, 
                            opacity: 0.9 
                        });
                        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 4 * (0.5 + Math.random() * 0.5);
                        orb.position.set(
                            radius * Math.cos(angle),
                            radius * Math.sin(angle),
                            -8
                        );
                        orb.userData = { 
                            velocity: new THREE.Vector3(
                                Math.cos(angle) * 0.03 * (0.5 + Math.random()),
                                Math.sin(angle) * 0.03 * (0.5 + Math.random()),
                                0.05 + Math.random() * 0.03
                            ), 
                            life: 0.8 + Math.random() * 0.4,
                            wobble: Math.random() * Math.PI * 2
                        };
                        scene.add(orb);
                        orbs.push(orb);
                    }
                }
            }

            orbs = orbs.filter(orb => {
                orb.userData.wobble += 0.1;
                orb.position.add(orb.userData.velocity);
                orb.position.x += Math.sin(orb.userData.wobble) * 0.02 * voiceAmplitude;
                orb.position.y += Math.cos(orb.userData.wobble) * 0.02 * voiceAmplitude;
                orb.userData.life -= 0.015;
                orb.material.opacity = orb.userData.life * 0.9;
                if (orb.userData.life <= 0) {
                    scene.remove(orb);
                    return false;
                }
                return true;
            });

            generateMandala(timeFactor);
            timeFactor += 0.01 + (voiceAmplitude * 0.05);

            renderer.render(scene, camera);
        }

        // Mandala Generation
        function generateMandala(timeFactor) {
            if (!needsRedraw) return;
            ctx.clearRect(0, 0, mandalaCanvas.width, mandalaCanvas.height);
            const centerX = mandalaCanvas.width / 2;
            const centerY = mandalaCanvas.height / 2;
            const audioFactor = voiceAmplitude + droneAmplitude;

            function drawRecursiveShape(x, y, r, level) {
                if (level > params.levels) return;
                const gradient = ctx.createLinearGradient(x - r, y - r, x + r, y + r);
                gradient.addColorStop(0, params.lineColor);
                gradient.addColorStop(0.5, params.secondaryColor);
                gradient.addColorStop(1, params.lineColor);

                ctx.lineWidth = params.lineWidth * (1 - (level - 1) / params.levels * 0.7) * (1 + audioFactor);
                ctx.strokeStyle = gradient;
                ctx.shadowBlur = 40 * audioFactor;
                ctx.shadowColor = params.secondaryColor;

                switch (params.patternType) {
                    case 'cymatic':
                        ctx.beginPath();
                        for (let i = 0; i < params.segments; i++) {
                            const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.5;
                            const mod = Math.sin(angle * level * 3 + timeFactor) * audioFactor;
                            const dist = r * (0.6 + mod * 1.2);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'vortex':
                        ctx.beginPath();
                        for (let i = 0; i < params.segments / level; i++) {
                            const angle = (i / (params.segments / level)) * Math.PI * 2 + timeFactor * 1.2;
                            const x1 = x + r * Math.cos(angle);
                            const y1 = y + r * Math.sin(angle);
                            const x2 = x + r * 0.4 * Math.cos(angle + Math.PI / (params.segments / level));
                            const y2 = y + r * 0.4 * Math.sin(angle + Math.PI / (params.segments / level));
                            ctx.moveTo(x, y);
                            ctx.quadraticCurveTo(x1, y1, x2, y2);
                        }
                        ctx.stroke();
                        break;
                    case 'nebula':
                        ctx.beginPath();
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + Math.sin(timeFactor * 0.4) * audioFactor;
                            const dist = r * (0.5 + Math.cos(timeFactor + i) * 0.7 * audioFactor);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'chaos':
                        ctx.beginPath();
                        const points = Math.floor(Math.random() * 8) + 5;
                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2 + Math.random() * 0.6 + timeFactor;
                            const dist = r * (0.3 + Math.sin(timeFactor + level) * 0.9 * audioFactor);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'flower':
                        ctx.beginPath();
                        for (let i = 0; i < 10; i++) {
                            const angle = (i / 10) * Math.PI * 2 + timeFactor * 0.8;
                            const dist = r * audioFactor * (0.6 + Math.sin(timeFactor) * 0.4);
                            ctx.arc(x + Math.cos(angle) * r * 0.5, y + Math.sin(angle) * r * 0.5, dist * 0.3, 0, Math.PI * 2);
                        }
                        ctx.stroke();
                        break;
                    case 'yantra':
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2 + timeFactor * 0.5;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(angle) * r * audioFactor, y + Math.sin(angle) * r * audioFactor);
                        }
                        ctx.stroke();
                        break;
                    case 'tunnel':
                        ctx.beginPath();
                        for (let i = 0; i < params.segments; i++) {
                            const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.9;
                            const depth = Math.sin(level * 0.6 + timeFactor) * r * 0.4 * audioFactor;
                            const dist = r * (1 - level / params.levels) * (1 + Math.cos(timeFactor) * 0.3);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist + depth);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'hypercube':
                        ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + timeFactor * 1.1;
                            const mod = Math.cos(level + timeFactor) * audioFactor;
                            const dist = r * (0.6 + mod * 0.6);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'mandelbrot':
                        ctx.beginPath();
                        const iterations = 20 + Math.floor(audioFactor * 20);
                        const buddhaPoints = [];
                        const scale = r / 200;

                        for (let i = 0; i < params.segments * 5; i++) {
                            let zr = 0, zi = 0;
                            const cr = (Math.cos(timeFactor + i * 0.1) * r * 0.5 * (1 + audioFactor)) / 200;
                            const ci = (Math.sin(timeFactor + i * 0.1) * r * 0.5 * (1 + audioFactor)) / 200;

                            for (let n = 0; n < iterations; n++) {
                                const zrNew = zr * zr - zi * zi + cr;
                                const ziNew = 2 * zr * zi + ci;
                                zr = zrNew;
                                zi = ziNew;

                                if (zr * zr + zi * zi > 4) {
                                    buddhaPoints.push({ x: zr * scale, y: zi * scale });
                                    break;
                                }
                            }
                        }

                        ctx.fillStyle = params.secondaryColor;
                        buddhaPoints.forEach(point => {
                            const px = x + point.x * (1 + audioFactor * 0.5);
                            const py = y + point.y * (1 + audioFactor * 0.5);
                            ctx.beginPath();
                            ctx.arc(px, py, 1 + audioFactor * 2, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        ctx.strokeStyle = gradient;
                        ctx.beginPath();
                        for (let i = 0; i < params.segments; i++) {
                            const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.5;
                            const mod = Math.sin(angle * level + timeFactor) * audioFactor * 0.3;
                            const dist = r * (0.7 + mod);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'pi':
                        ctx.beginPath();
                        const piDigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
                        for (let i = 0; i < params.segments; i++) {
                            const digit = piDigits[i % piDigits.length];
                            const angle = (i / params.segments) * Math.PI * 2 + timeFactor + digit * 0.1;
                            const dist = r * (0.5 + digit / 10 * audioFactor);
                            ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'schumann':
                        ctx.beginPath();
                        const resonance = 7.83 * (1 + audioFactor);
                        for (let i = 0; i < params.segments; i++) {
                            const angle = (i / params.segments) * Math.PI * 2 + timeFactor * 0.3;
                            const ripple = Math.sin(timeFactor + level * resonance * 0.1) * r * 0.4 * audioFactor;
                            const dist = r * (0.6 + ripple);
                            ctx.arc(x, y, dist, angle, angle + Math.PI / params.segments);
                        }
                        ctx.stroke();
                        break;
                    case 'floweroflife':
                        ctx.beginPath();
                        const circleCount = 6;
                        for (let i = 0; i < circleCount; i++) {
                            const angle = (i / circleCount) * Math.PI * 2 + timeFactor * 0.2;
                            const dist = r * 0.5 * (1 + audioFactor * 0.3);
                            ctx.arc(
                                x + Math.cos(angle) * dist,
                                y + Math.sin(angle) * dist,
                                r * params.scaleFactor * (1 + audioFactor),
                                0,
                                Math.PI * 2
                            );
                        }
                        ctx.stroke();
                        break;
                    case 'e8':
                        ctx.beginPath();
                        const nodes = 8;
                        for (let i = 0; i < nodes; i++) {
                            const angle1 = (i / nodes) * Math.PI * 2 + timeFactor * 0.4;
                            const dist1 = r * (0.5 + Math.sin(timeFactor) * audioFactor);
                            const x1 = x + Math.cos(angle1) * dist1;
                            const y1 = y + Math.sin(angle1) * dist1;
                            for (let j = 0; j < nodes; j++) {
                                const angle2 = (j / nodes) * Math.PI * 2 + timeFactor * 0.4;
                                const dist2 = r * (0.5 + Math.cos(timeFactor) * audioFactor);
                                const x2 = x + Math.cos(angle2) * dist2;
                                const y2 = y + Math.sin(angle2) * dist2;
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                            }
                        }
                        ctx.stroke();
                        break;
                }

                drawRecursiveShape(x, y, r * params.scaleFactor, level + 1);
            }

            for (let i = 0; i < params.segments; i++) {
                const angle = (i / params.segments) * Math.PI * 2 + timeFactor * params.modulation;
                const x = centerX + params.initialRadius * Math.cos(angle) * (1 + audioFactor * 0.5);
                const y = centerY + params.initialRadius * Math.sin(angle) * (1 + audioFactor * 0.5);
                drawRecursiveShape(x, y, params.initialRadius * params.scaleFactor, 1);
            }

            ctx.fillStyle = params.secondaryColor;
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = params.initialRadius * (Math.random() * 0.5 + 0.5) * (1 + audioFactor);
                ctx.beginPath();
                ctx.arc(centerX + Math.cos(angle) * dist, centerY + Math.sin(angle) * dist, 2 * (1 + audioFactor), 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(centerX, centerY, mandalaCanvas.width / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            needsRedraw = false;
        }

        // Presets
        function applyPreset(preset) {
            switch (preset) {
                case 'mandala':
                    Object.assign(params, { segments: 8, levels: 5, scaleFactor: 0.75, initialRadius: 300, lineColor: '#ff4500', secondaryColor: '#ffd700', patternType: 'cymatic', baseFreq: 108, waveform: 'sine', modulation: 0.8 });
                    break;
                case 'yantra':
                    Object.assign(params, { segments: 4, levels: 4, scaleFactor: 0.65, initialRadius: 200, lineColor: '#ff00ff', secondaryColor: '#ffd700', patternType: 'yantra', baseFreq: 136.1, waveform: 'triangle', modulation: 1.2 });
                    break;
                case 'sufi':
                    Object.assign(params, { segments: 12, levels: 3, scaleFactor: 0.8, initialRadius: 280, lineColor: '#00ced1', secondaryColor: '#228b22', patternType: 'vortex', baseFreq: 174, waveform: 'sawtooth', modulation: 1.8 });
                    break;
                case 'zen':
                    Object.assign(params, { segments: 1, levels: 1, scaleFactor: 0.95, initialRadius: 180, lineColor: '#000000', secondaryColor: '#ffffff', patternType: 'flower', baseFreq: 220, waveform: 'sine', modulation: 0.2 });
                    break;
                case 'mandelbrot':
                    Object.assign(params, { segments: 6, levels: 3, scaleFactor: 0.8, initialRadius: 250, lineColor: '#ffd700', secondaryColor: '#ff4500', patternType: 'mandelbrot', baseFreq: 432, waveform: 'sine', modulation: 1.0 });
                    break;
                case 'pi':
                    Object.assign(params, { segments: 10, levels: 4, scaleFactor: 0.7, initialRadius: 200, lineColor: '#ff8c00', secondaryColor: '#1e90ff', patternType: 'pi', baseFreq: 314, waveform: 'triangle', modulation: 0.9 });
                    break;
                case 'schumann':
                    Object.assign(params, { segments: 7, levels: 5, scaleFactor: 0.9, initialRadius: 240, lineColor: '#00fa9a', secondaryColor: '#4682b4', patternType: 'schumann', baseFreq: 7.83, waveform: 'sine', modulation: 1.1 });
                    break;
                case 'floweroflife':
                    Object.assign(params, { segments: 6, levels: 4, scaleFactor: 0.55, initialRadius: 280, lineColor: '#ffd700', secondaryColor: '#ff4500', patternType: 'floweroflife', baseFreq: 528, waveform: 'sine', modulation: 0.7 });
                    break;
                case 'e8':
                    Object.assign(params, { segments: 8, levels: 3, scaleFactor: 0.85, initialRadius: 220, lineColor: '#9400d3', secondaryColor: '#00ffff', patternType: 'e8', baseFreq: 639, waveform: 'sawtooth', modulation: 1.4 });
                    break;
            }
            if (droneOscillator) droneOscillator.frequency.value = params.baseFreq;
            needsRedraw = true;
            generateMandala(0);
        }

        // Utility Functions
        function downloadMandala() {
            const link = document.createElement('a');
            link.download = `cosmic-level-${level}.png`;
            link.href = mandalaCanvas.toDataURL('image/png');
            link.click();
        }

        function animate(timestamp) {
            if (timestamp - lastUpdate > 33) {
                generateMandala(timeFactor);
                timeFactor += 0.01 + (voiceAmplitude * 0.05);
                lastUpdate = timestamp;
            }
            animationId = requestAnimationFrame(animate);
        }

        // Initialization
        function init() {
            document.getElementById('startGame').addEventListener('click', () => {
                resetGame();
                initVoiceControl();
                animate(performance.now());
            });
            document.getElementById('drone').addEventListener('click', toggleDrone);
            document.getElementById('download').addEventListener('click', downloadMandala);

            initVR();
            applyPreset(levels[0].preset);
            generateMandala(0);

            window.addEventListener('unload', () => {
                if (droneOscillator) droneOscillator.stop();
                if (audioContext) audioContext.close();
                cancelAnimationFrame(animationId);
            });
        }

        window.onload = init;
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome</title>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
    body {
    font-family: Arial, sans-serif;
    background-color: #121212;
    color: #e0e0e0;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    padding-top: 20px;
}

.container {
    background-color: #1e1e1e;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    max-width: 1000px;
    width: 90%;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    color: #4db6ac;
    font-weight: bold;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 30px;
    background-color: #242424;
    border-radius: 8px;
    overflow: hidden;
}

th, td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #333;
}

th {
    background-color: #4db6ac;
    color: #121212;
    font-weight: bold;
}

tr:nth-child(even) {
    background-color: #2a2a2a;
}

tr:hover {
    background-color: #333;
}

.error-message {
    color: #e57373;
    text-align: center;
    margin-bottom: 20px;
    font-weight: bold;
}

.nav-links {
    width: 100%;
    padding: 15px;
    background-color: #263238;
    color: white;
    text-align: center;
    margin-bottom: 20px;
    border-radius: 6px;
}

.nav-links a, .nav-links button {
    color: #80cbc4;
    margin: 0 15px;
    text-decoration: none;
    font-weight: bold;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    transition: color 0.3s ease;
}

.nav-links a:hover, .nav-links button:hover {
    color: #4db6ac;
}

#inviteLink {
    display: none;
    margin-top: 10px;
    padding: 12px;
    width: 100%;
    box-sizing: border-box;
    border: 1px solid #555;
    border-radius: 6px;
    background-color: #1e1e1e;
    color: #e0e0e0;
}

.share-buttons {
    margin-top: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
}

.share-buttons button, #generateLinkBtn, #copyLinkBtn {
    padding: 10px 18px;
    background-color: #4db6ac;
    color: #121212;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s ease;
}

.share-buttons button:hover, #generateLinkBtn:hover, #copyLinkBtn:hover {
    background-color: #388e8e;
}
 .add-connection-btn {
        background-color: #4db6ac;
        color: #121212;
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .add-connection-btn:hover {
        background-color: #26a69a;
    }

    .add-connection-btn:active {
        transform: scale(0.98);
    }
    </style>
</head>
<body>
    <div class="nav-links">
        <a href="invite.html">Invite</a>
        <a href="profile.html">Profile</a>
        <button id="signOutBtn">Sign Out</button>
    </div>
<div class="container">
    <h1>Welcome</h1>
    <p id="welcomeMessage"></p>
    <div class="error-message" id="errorMessage"></div>

    <button id="togglePhysics">Toggle Physics</button>

    <!-- Visualization Container -->
    <div id="visualization-container" style="background-color: #1e1e1e; padding: 30px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); margin-top: 2rem; max-width: 1000px; width: 90%; border: 1px solid #333; transition: transform 0.3s ease, box-shadow 0.3s ease;">
        <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; text-align: center; color: #4db6ac; text-transform: uppercase; letter-spacing: 1px;">The Mandala</h2>
        <div id="visualization" style="width: 100%; height: 500px; background: radial-gradient(circle, rgba(77, 182, 172, 0.2) 0%, rgba(30, 30, 30, 0.9) 100%); border-radius: 8px; border: 1px solid #333;"></div>
    </div>
</div>


         <h2>Accepted Invitations</h2>
        <table id="invitationsTable">
            <thead>
                <tr>
                    <th>Accepted By</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>

        <h2>Generate Invitation Link</h2>
        <button id="generateLinkBtn">Generate Link</button>
        <input type="text" id="inviteLink" readonly>
        <button id="copyLinkBtn" style="display: none;">Copy Link</button>
    </div>





    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyA8nC973Wex5WJVgovi_MVzDtmuL4IOhjE",
            authDomain: "mandala-5165e.firebaseapp.com",
            projectId: "mandala-5165e",
            storageBucket: "mandala-5165e.appspot.com",
            messagingSenderId: "569537405023",
            appId: "1:569537405023:web:e7f795e6280f7a21e9bbea",
            measurementId: "G-TER99X7NBT"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        auth.onAuthStateChanged(user => {
            if (user) {
                document.getElementById("welcomeMessage").textContent = `Hello, ${user.email}!`;
                fetchAcceptedInvitations(user);
            } else {
                window.location.href = '/index.html';
            }
        });

function fetchAcceptedInvitations(currentUser) {
    const invitationsTable = document.getElementById("invitationsTable").getElementsByTagName('tbody')[0];
    invitationsTable.innerHTML = "";

    db.collection("invitations").get()
        .then(snapshot => {
            const allAcceptedInvitations = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.acceptedByUser?.length > 0) {
                    allAcceptedInvitations.push(data);
                }
            });

            // Identify direct connections (current user's invitations)
            const directConnectionsEmails = new Set();
            const directInvitations = allAcceptedInvitations.filter(data => {
                const isSender = data.fromUserId === currentUser.uid;
                const isAcceptor = data.acceptedByUser.some(u => u.email === currentUser.email);
                return isSender || isAcceptor;
            });

            directInvitations.forEach(data => {
                data.acceptedByUser.forEach(user => {
                    if (user.email !== currentUser.email) {
                        directConnectionsEmails.add(user.email);
                    }
                });
            });

            // Identify second-degree invitations (involving direct connections)
            const secondDegreeInvitations = allAcceptedInvitations.filter(data => {
                const senderEmail = data.fromUserEmail;
                const acceptorEmails = data.acceptedByUser.map(u => u.email);
                return directConnectionsEmails.has(senderEmail) || acceptorEmails.some(email => directConnectionsEmails.has(email));
            });

            // Combine and deduplicate invitations
            const combinedInvitations = [...new Set([...directInvitations, ...secondDegreeInvitations])];

            // Process combined invitations to build maps
            const acceptedUsersMap = new Map();
            const connections = new Set();

            combinedInvitations.forEach(data => {
                data.acceptedByUser.forEach(user => {
                    const key = user.email;
                    if (!acceptedUsersMap.has(key) && key !== currentUser.email) {
                        acceptedUsersMap.set(key, user);
                    }
                });

                data.acceptedByUser.forEach(user => {
                    const connection = [data.fromUserEmail, user.email].sort().join('-');
                    connections.add(connection);
                });
            });

            // Display users and their invitations
            acceptedUsersMap.forEach(user => {
                const tr = document.createElement("tr");
                tr.innerHTML = `<td>${user.email}<br>${user.name}</td>`;
                invitationsTable.appendChild(tr);
                displayAcceptedInvitesByUser(currentUser, user, allAcceptedInvitations); // Pass all accepted
            });

            createVisualization(Array.from(acceptedUsersMap.values()), Array.from(connections));
        })
        .catch(error => {
            console.error("Error fetching invitations:", error);
            document.getElementById("errorMessage").textContent = "Error loading invitations.";
        });
}

function displayAcceptedInvitesByUser(currentUser, acceptedUser, allInvitations) {
    // Existing code remains the same, but uses allInvitations which now includes all accepted
    const userInvitations = allInvitations.filter(invite => 
        invite.fromUserEmail === acceptedUser.email ||
        (invite.acceptedByUser && invite.acceptedByUser.some(u => u.email === acceptedUser.email))
    );
    
    const sectionId = `userSection-${acceptedUser.email.replace(/[@.]/g, '_')}`;
    let section = document.getElementById(sectionId);

    if (section) section.remove();

    section = document.createElement('div');
    section.id = sectionId;
    section.style.marginTop = "2rem";
    section.innerHTML = `
        <h3 style="color: #4db6ac; text-transform: uppercase;">
            Invitations for ${acceptedUser.name} (${acceptedUser.email})
        </h3>
        <table style="width: 100%; border-collapse: collapse; background-color: #242424; border-radius: 8px; overflow: hidden;">
            <thead>
                <tr>
                    <th style="background-color: #4db6ac; color: #121212; padding: 12px;">Role</th>
                    <th style="background-color: #4db6ac; color: #121212; padding: 12px;">Other Party</th>
                    <th style="background-color: #4db6ac; color: #121212; padding: 12px;">Action</th>
                </tr>
            </thead>
            <tbody id="${sectionId}-tbody"></tbody>
        </table>
    `;
    document.querySelector('.container').appendChild(section);

    const tbody = document.getElementById(`${sectionId}-tbody`);
  

    if (userInvitations.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" style="padding: 12px; text-align: center;">No invitations found.</td></tr>`;
    }

    userInvitations.forEach(invite => {
        let role, otherParties;
        if (invite.fromUserEmail === acceptedUser.email) {
            role = "Sent";
            otherParties = invite.acceptedByUser ? 
                invite.acceptedByUser.filter(u => u.email !== acceptedUser.email) : [];
        } else {
            role = "Received";
            otherParties = [{ 
                email: invite.fromUserEmail, 
                name: invite.fromUserName || invite.fromUserEmail 
            }];
        }

        if (otherParties.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td style="padding: 12px; border-bottom: 1px solid #333;">${role}</td>
                <td style="padding: 12px; border-bottom: 1px solid #333;">No one yet</td>
                <td style="padding: 12px; border-bottom: 1px solid #333;"></td>
            `;
            tbody.appendChild(row);
        } else {
            otherParties.forEach(user => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="padding: 12px; border-bottom: 1px solid #333;">${role}</td>
                    <td style="padding: 12px; border-bottom: 1px solid #333;">
                        ${user.name} (${user.email})
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid #333;">
                        <button class="add-connection-btn">
                            Add Connection
                        </button>
                    </td>
                `;

                const button = row.querySelector('.add-connection-btn');
                button.addEventListener('click', () => handleAddConnection(currentUser, user));
                
                tbody.appendChild(row);
            });
        }
    });
}

function handleAddConnection(currentUser, targetUser) {
    if (currentUser.email === targetUser.email) {
        alert('Cannot add yourself as a connection.');
        return;
    }

    const sortedEmails = [currentUser.email, targetUser.email].sort();
    const connectionId = sortedEmails.join('-');

    const connectionRef = db.collection('connections').doc(connectionId);

    connectionRef.get().then(doc => {
        if (doc.exists) {
            alert('Connection already exists!');
            return;
        }

        return connectionRef.set({
            users: sortedEmails,
            usersInfo: [
                { email: currentUser.email, name: currentUser.displayName },
                { email: targetUser.email, name: targetUser.name }
            ],
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
    }).then(() => {
        // Check if an invite already exists from the current user to the target user
        return db.collection("invitations")
            .where("fromUserEmail", "==", currentUser.email)
            .where("toUserEmail", "==", targetUser.email)
            .limit(1)
            .get();
    }).then(snapshot => {
        if (!snapshot.empty) {
            // Update existing invitation
            const inviteDoc = snapshot.docs[0];
            const inviteRef = db.collection("invitations").doc(inviteDoc.id);
            const inviteData = inviteDoc.data();

            const updatedAcceptedBy = inviteData.acceptedByUser || [];
            if (!updatedAcceptedBy.some(user => user.email === targetUser.email)) {
                updatedAcceptedBy.push({ email: targetUser.email, name: targetUser.name });
            }

            return inviteRef.update({ acceptedByUser: updatedAcceptedBy, status: "accepted" });
        } else {
            // Create a new invitation if none exists
            return db.collection("invitations").add({
                fromUserId: currentUser.uid,
                fromUserEmail: currentUser.email,
                fromUserName: currentUser.displayName,
                toUserId: targetUser.uid || null, // if available
                toUserEmail: targetUser.email,
                toUserName: targetUser.name,
                status: "accepted",
                acceptedByUser: [{ email: targetUser.email, name: targetUser.name }],
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
    }).then(() => {
        alert('Connection added successfully!');
        fetchAcceptedInvitations(currentUser);
    }).catch(error => {
        console.error('Error adding connection:', error);
        alert('Failed to add connection.');
    });
}


let simulation = null;
let currentPhysics = false;
let currentUsers = [];
let currentConnections = [];

function createVisualization(users, connections, enablePhysics = false) {
  // Clear previous visualization
  const container = d3.select("#visualization");
  container.html("");
  if (simulation) simulation.stop();

  const width = 600;
  const height = 500;
  const centerX = width / 2;
  const centerY = height / 2;

  const svg = container.append("svg")
    .attr("viewBox", `0 0 ${width} ${height}`)
    .style("width", "100%")
    .style("max-width", "600px")
    .style("margin", "0 auto");

  // Create nodes with initial positions
  const nodes = users.map(user => ({
    id: user.email,
    label: user.email,
    name: user.name,
    x: centerX + (Math.random() - 0.5) * 50,
    y: centerY + (Math.random() - 0.5) * 50
  }));

  if (enablePhysics) {
    // Create proper links with node references
    const links = connections.map(connection => {
      const [sourceId, targetId] = connection.split('-');
      return {
        source: nodes.find(n => n.id === sourceId),
        target: nodes.find(n => n.id === targetId)
      };
    }).filter(l => l.source && l.target);

    // Create force simulation
    simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links)
        .id(d => d.id)
        .distance(100)
        .strength(0.2))
      .force("charge", d3.forceManyBody().strength(-150))
      .force("collide", d3.forceCollide(20))
      .force("center", d3.forceCenter(centerX, centerY))
      .alphaDecay(0.02);

    // Create links group
    const linksGroup = svg.append("g").attr("class", "links");
    const nodesGroup = svg.append("g").attr("class", "nodes");
    const labelsGroup = svg.append("g").attr("class", "labels");

    // Create links
    const link = linksGroup.selectAll(".link")
      .data(links)
      .enter().append("line")
      .attr("class", "link")
      .attr("stroke", "#4CAF50")
      .attr("stroke-width", 2)
      .attr("opacity", 0.5);

    // Create nodes
    const node = nodesGroup.selectAll(".node")
      .data(nodes)
      .enter().append("circle")
      .attr("class", "node")
      .attr("r", 8)
      .attr("fill", "#4CAF50");

    // Create labels
    const label = labelsGroup.selectAll(".label")
      .data(nodes)
      .enter().append("text")
      .attr("class", "label")
      .attr("text-anchor", "middle")
      .attr("dy", "0.35em")
      .attr("font-size", "12")
      .text(d => d.label);

    // Update positions on tick
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      label
        .attr("x", d => d.x)
        .attr("y", d => d.y + 20);
    });

  } else {
    // Circle layout implementation
    const radius = 200;
    const nodePositions = new Map();

    nodes.forEach((node, i) => {
      const angle = (i * 2 * Math.PI) / nodes.length;
      nodePositions.set(node.id, {
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        angle: angle
      });
    });

    // Draw connections
    connections.forEach(connection => {
      const [email1, email2] = connection.split('-');
      const pos1 = nodePositions.get(email1);
      const pos2 = nodePositions.get(email2);
      if (pos1 && pos2) {
        svg.append("line")
          .attr("x1", pos1.x)
          .attr("y1", pos1.y)
          .attr("x2", pos2.x)
          .attr("y2", pos2.y)
          .attr("stroke", "#4CAF50")
          .attr("stroke-width", 2)
          .attr("opacity", 0.5);
      }
    });

    // Center node and spokes
    svg.append("circle")
      .attr("cx", centerX)
      .attr("cy", centerY)
      .attr("r", 8)
      .attr("fill", "#4CAF50");

    nodes.forEach(node => {
      const pos = nodePositions.get(node.id);
      svg.append("line")
        .attr("x1", centerX)
        .attr("y1", centerY)
        .attr("x2", pos.x)
        .attr("y2", pos.y)
        .attr("stroke", "#4CAF50")
        .attr("stroke-width", 1)
        .attr("opacity", 0.2);
    });

    // Outer nodes and labels
    nodes.forEach(node => {
      const pos = nodePositions.get(node.id);
      svg.append("circle")
        .attr("cx", pos.x)
        .attr("cy", pos.y)
        .attr("r", 6)
        .attr("fill", "#4CAF50");

      svg.append("text")
        .attr("x", pos.x)
        .attr("y", pos.y + 20)
        .attr("text-anchor", "middle")
        .attr("font-size", "12")
        .attr("transform", `rotate(${pos.angle * 180 / Math.PI + (pos.angle > Math.PI ? 180 : 0)}, ${pos.x}, ${pos.y})`)
        .text(node.label);
    });
  }
}
// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', () => {
    // Ensure elements exist before accessing them
    const toggleButton = document.getElementById('togglePhysics');
    const visualizationDiv = document.getElementById('visualization');
    
    if (!toggleButton || !visualizationDiv) {
        console.error('Required elements not found!');
        return;
    }
        
    document.getElementById("generateLinkBtn").addEventListener("click", () => {
        const user = auth.currentUser;
        if (!user) return;
        
        const uniqueId = Math.random().toString(36).substr(2, 9);
        const inviteLink = `https://my-mandala.com/?inviteId=${uniqueId}`;

        db.collection("invitations").doc(uniqueId).set({
            fromUserId: user.uid,
            fromUserEmail: user.email,
            status: "open",
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        }).then(() => {
            const inviteLinkInput = document.getElementById("inviteLink");
            inviteLinkInput.value = inviteLink;
            inviteLinkInput.style.display = "block";
            document.getElementById("copyLinkBtn").style.display = "inline-block";
        });
    });

    document.getElementById("copyLinkBtn").addEventListener("click", () => {
        const inviteLinkInput = document.getElementById("inviteLink");
        inviteLinkInput.select();
        document.execCommand("copy");
        alert("Link copied to clipboard!");
    });

    document.getElementById("signOutBtn").addEventListener("click", () => {
        auth.signOut().then(() => {
            window.location.href = '/index.html';
        });
    });

    // Initialize visualization
    createVisualization();

    // Update visualization when tables change
    const observer = new MutationObserver(() => {
        createVisualization();
    });

    observer.observe(document.querySelector('.container'), {
        subtree: true,
        childList: true
    });
}); // <-- This closing brace and parenthesis were missing
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome</title>
    <!-- Firebase scripts -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <!-- D3.js script for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Styles for the page -->
    <style>
      body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding-top: 20px;
        }

        .container {
            background-color: #1e1e1e;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 1000px;
            width: 90%;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #90a4ae;
            font-weight: bold;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            background-color: #242424;
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #424242;
            color: #e0e0e0;
        }

        th {
            background-color: #424242;
            color: #f5f5f5;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #212121;
        }

        tr:hover {
            background-color: #333;
        }

        .error-message {
            color: #e57373;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .nav-links {
            width: 100%;
            padding: 15px;
            background-color: #263238;
            color: white;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 6px;
        }

        .nav-links a, .nav-links button {
            color: #bdbdbd;
            margin: 0 15px;
            text-decoration: none;
            font-weight: bold;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: color 0.3s ease;
        }

        .nav-links a:hover, .nav-links button:hover {
            color: #90a4ae;
        }

        #inviteLink {
            display: none;
            margin-top: 10px;
            padding: 12px;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid #555;
            border-radius: 6px;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        .share-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .share-buttons button, #generateLinkBtn, #copyLinkBtn {
            padding: 10px 18px;
            background-color: #424242;
            color: #e0e0e0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .share-buttons button:hover, #generateLinkBtn:hover, #copyLinkBtn:hover {
            background-color: #388e8e;
        }

        .add-connection-btn {
            background-color: #424242;
            color: #e0e0e0;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .add-connection-btn:hover {
            background-color: #263238;
        }

        .add-connection-btn:active {
            transform: scale(0.98);
        }

        #visualization-container {
            background-color: #1e1e1e;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            margin-top: 2rem;
            max-width: 1000px;
            width: 90%;
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #visualization-container h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            color: #bdbdbd;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #visualization {
            width: 100%;
            height: 500px;
            background: radial-gradient(circle, rgba(77, 182, 172, 0.2) 0%, rgba(30, 30, 30, 0.9) 100%);
            border-radius: 8px;
            border: 1px solid #333;
        }

        .accept-btn, .reject-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-weight: bold;
        }

        .accept-btn {
            background-color: #4CAF50;
            color: white;
        }

        .reject-btn {
            background-color: #f44336;
            color: white;
        }

        #suggestedConnectionsTable {
            display: table; /* Initially visible */
        }
    </style>
</head>
<body>
    <!-- Navigation links -->
    <div class="nav-links">
        <a href="invite.html">Invite</a>
        <a href="profile.html">Profile</a>
        <button id="signOutBtn">Sign Out</button>
    </div>
    <!-- Main container -->
    <div class="container">
        <h1>Welcome</h1>
        <p id="welcomeMessage"></p>
        <p id="errorMessage" class="error-message"></p>

        <button id="togglePhysics">Toggle Physics</button>

        <!-- Visualization Container -->
        <div id="visualization-container">
            <h2>The Mandala</h2>
            <div id="visualization"></div>
        </div>

        <h2>Connected</h2>
        <table id="invitationsTable">
            <thead>
                <tr>
                    <th>User</th>
                    <th>User ID</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>

        <h2>Suggested Connections</h2>
        <table id="suggestedConnectionsTable">
            <thead>
                <tr>
                    <th>User</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>

        <h2>Generate Invitation Link</h2>
        <button id="generateLinkBtn">Generate Link</button>
        <input type="text" id="inviteLink" readonly>
        <button id="copyLinkBtn" style="display: none;">Copy Link</button>

        <button id="toggleSuggestions">Hide Suggestions</button>
    </div>

    <!-- Main JavaScript -->
    <script>
// Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8nC973Wex5WJVgovi_MVzDtmuL4IOhjE",
            authDomain: "mandala-5165e.firebaseapp.com",
            projectId: "mandala-5165e",
            storageBucket: "mandala-5165e.appspot.com",
            messagingSenderId: "569537405023",
            appId: "1:569537405023:web:e7f795e6280f7a21e9bbea",
            measurementId: "G-TER99X7NBT"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // Authentication state listener
        auth.onAuthStateChanged(user => {
            if (user) {
                document.getElementById("welcomeMessage").textContent = `Hello, ${user.email}!`;
                fetchInvitations(user);
            } else {
                window.location.href = '/index.html';
            }
        });

        // Toggle Suggestions Table
        let isSuggestionsVisible = true;
        document.getElementById('toggleSuggestions').addEventListener('click', function() {
            const table = document.getElementById('suggestedConnectionsTable');
            isSuggestionsVisible = !isSuggestionsVisible;
            table.style.display = isSuggestionsVisible ? 'table' : 'none';
            this.textContent = isSuggestionsVisible ? 'Hide Suggestions' : 'Show Suggestions';
        });


        function fetchInvitations(currentUser) {
            const invitationsTable = document.getElementById("invitationsTable").getElementsByTagName('tbody')[0];
            invitationsTable.innerHTML = "";

            db.collection("invitations").get()
                .then(snapshot => {
                    const allInvitations = [];
                    const invitationsMap = new Map();

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const docId = doc.id;
                        if (isValidData(data)) {
                            allInvitations.push({ ...data, docId: docId });
                            const connectionId = [data.fromUserEmail, data.toUserEmail].sort().join('-');
                            invitationsMap.set(connectionId, { ...data, docId: docId });
                        } else {
                            console.warn("Skipping invalid data:", data);
                        }
                    });

                    const mutualConnections = getMutualConnections(allInvitations);
                    const acceptedUsersMap = new Map();
                    const connections = new Set();

                    allInvitations.forEach(data => {
                        if (isValidData(data)) {
                            if (!acceptedUsersMap.has(data.fromUserEmail) && data.fromUserEmail !== currentUser.email) {
                                acceptedUsersMap.set(data.fromUserEmail, { email: data.fromUserEmail, name: data.fromUserName, userId: data.fromUserId });
                            }
                            if (!acceptedUsersMap.has(data.toUserEmail) && data.toUserEmail !== currentUser.email) {
                                acceptedUsersMap.set(data.toUserEmail, { email: data.toUserEmail, name: data.toUserName, userId: data.toUserId });
                            }
                            if (mutualConnections.has([data.fromUserEmail, data.toUserEmail].sort().join('-'))) {
                                connections.add([data.fromUserEmail, data.toUserEmail].sort().join('-'));
                            }
                        }
                    });

                    currentUsers = Array.from(acceptedUsersMap.values());
                    currentConnections = Array.from(connections);

                    createVisualization(currentUsers, currentConnections, currentPhysics);
                    displayInvitations(currentUser, allInvitations, invitationsMap, mutualConnections);
                    suggestConnections(allInvitations, currentUser);
                })
                .catch(error => {
                    console.error("Error fetching invitations:", error);
                    document.getElementById("errorMessage").textContent = "Error loading invitations.";
                });
        }


        function getMutualConnections(invitations) {
            const mutualConnections = new Set();
            const invitationMap = new Map();

            invitations.forEach(invite => {
                const connectionId = [invite.fromUserEmail, invite.toUserEmail].sort().join('-');
                invitationMap.set(connectionId, invite);
            });

            invitations.forEach(invite => {
                const connectionId = [invite.fromUserEmail, invite.toUserEmail].sort().join('-');
                const reciprocalConnectionId = [invite.toUserEmail, invite.fromUserEmail].sort().join('-');
                if (invitationMap.has(reciprocalConnectionId)) {
                    mutualConnections.add(connectionId);
                }
            });
            return mutualConnections;
        }

        function displayInvitations(currentUser, invitations, invitationsMap, mutualConnections) {
            const invitationsTable = document.getElementById("invitationsTable").getElementsByTagName('tbody')[0];
            invitationsTable.innerHTML = "";
            const processedConnections = new Set();

            invitations.forEach(invite => {
              if (invite && invite.fromUserEmail && invite.toUserEmail && invite.fromUserId && invite.toUserId) {
                    const email1 = invite.fromUserEmail;
                    const email2 = invite.toUserEmail;
                    const connectionId = [email1, email2].sort().join('-');
                    const otherUserEmail = (email1 === currentUser.email) ? email2 : email1;
                    const otherUserId = (email1 === currentUser.email) ? invite.toUserId : invite.fromUserId;
                    const isCurrentUserTheReceiver = invite.toUserEmail === currentUser.email;
                    const status = invite.status || "pending";

                    if (mutualConnections.has(connectionId) || status === "accepted") {
                        if (!processedConnections.has(connectionId)) {
                            const tr = document.createElement("tr");
                            tr.innerHTML = `
                                <td>${otherUserEmail}</td>
                                <td>${otherUserId || 'N/A'}</td>
                                <td>Connected</td>
                            `;
                            invitationsTable.appendChild(tr);
                            processedConnections.add(connectionId);
                        }
                    } else if (isCurrentUserTheReceiver && status === "pending") {
                        if (!processedConnections.has(connectionId)) {
                            const tr = document.createElement("tr");
                            const acceptButton = document.createElement("button");
                            acceptButton.textContent = "Accept";
                            acceptButton.className = "accept-btn";
                            acceptButton.addEventListener("click", () => handleAcceptInvitation(invite.docId));

                            const rejectButton = document.createElement("button");
                            rejectButton.textContent = "Reject";
                            rejectButton.className = "reject-btn";
                            rejectButton.addEventListener("click", () => handleRejectInvitation(invite.docId));

                            tr.innerHTML = `
                                <td>${invite.fromUserEmail}</td>
                                 <td>${invite.fromUserId}</td>
                                <td>Pending<br/>${acceptButton.outerHTML}${rejectButton.outerHTML}</td>
                            `;
                            invitationsTable.appendChild(tr);
                            processedConnections.add(connectionId);
                        }
                    } else if (invite.fromUserEmail === currentUser.email && invite.toUserEmail === otherUserEmail && status === "pending") {
                        if (!processedConnections.has(connectionId)) {
                            const tr = document.createElement("tr");
                            tr.innerHTML = `
                                <td>${otherUserEmail}</td>
                                 <td>${invite.toUserId}</td>
                                <td>Pending</td>
                            `;
                            invitationsTable.appendChild(tr);
                            processedConnections.add(connectionId);
                        }
                    }
                } else {
                    console.warn("Skipping invalid invitation data:", invite);
                }
            });
        }



        async function suggestConnections(existingInvitations, currentUser) {
          const suggestedConnectionsTable = document.getElementById("suggestedConnectionsTable").getElementsByTagName('tbody')[0];
          suggestedConnectionsTable.innerHTML = "";

          const myEmail = currentUser.email;
          const myConnectionsEmails = new Set();

          existingInvitations.forEach(inviteData => {
              if (inviteData && inviteData.fromUserEmail && inviteData.toUserEmail) {
                  if (inviteData.fromUserEmail === myEmail) {
                      myConnectionsEmails.add(inviteData.toUserEmail);
                  } else if (inviteData.toUserEmail === myEmail) {
                      myConnectionsEmails.add(inviteData.fromUserEmail);
                  }
              }
          });

          const potentialConnections = new Set();

          for (const connectedEmail of myConnectionsEmails) {
              const connectedUserInvitations = await db.collection("invitations")
                  .where("fromUserEmail", "==", connectedEmail)
                  .get();

              connectedUserInvitations.forEach(doc => {
                  const inviteData = doc.data();
                  if (inviteData && inviteData.toUserEmail && inviteData.fromUserEmail) {
                      const potentialEmail = inviteData.toUserEmail;
                      if (potentialEmail !== myEmail && !myConnectionsEmails.has(potentialEmail) && !isAmongExisting(potentialEmail, existingInvitations, myEmail)) {
                          potentialConnections.add(potentialEmail);
                      }
                  }
              });

              const connectedUserInvitationsMe = await db.collection("invitations")
                  .where("toUserEmail", "==", connectedEmail)
                  .get();

              connectedUserInvitationsMe.forEach(doc => {
                  const inviteData = doc.data();
                  if (inviteData && inviteData.fromUserEmail && inviteData.toUserEmail) {
                      const potentialEmail = inviteData.fromUserEmail;
                      if (potentialEmail !== myEmail && !myConnectionsEmails.has(potentialEmail) && !isAmongExisting(potentialEmail, existingInvitations, myEmail)) {
                          potentialConnections.add(potentialEmail);
                      }
                  }
              });
          }

          potentialConnections.forEach(potentialEmail => {
              const tr = document.createElement("tr");
              tr.innerHTML = `
                  <td>${potentialEmail}</td>
                  <td>
                      <button class="add-connection-btn" data-email="${potentialEmail}">
                          Invite
                      </button>
                  </td>
              `;
              suggestedConnectionsTable.appendChild(tr);

              const button = tr.querySelector('.add-connection-btn');
              button.addEventListener('click', (event) => {
                  const email = event.target.dataset.email;
                  handleAddConnection(currentUser, { email: email, name: email });
              });
          });
      }

      function isAmongExisting(potentialEmail, existingInvitations, myEmail) {
          for (const invite of existingInvitations) {
              if (invite && invite.toUserEmail && invite.fromUserEmail) {
                if ((invite.fromUserEmail === myEmail && invite.toUserEmail === potentialEmail) ||
                      (invite.toUserEmail === myEmail && invite.fromUserEmail === potentialEmail)) {
                      return true;
                  }
              }
          }
          return false;
      }


        function handleAddConnection(currentUser, targetUser) {
            if (currentUser.email === targetUser.email) {
                alert('Cannot add yourself.');
                return;
            }

            db.collection("invitations").add({
                fromUserId: currentUser.uid,
                fromUserEmail: currentUser.email,
                fromUserName: currentUser.displayName || currentUser.email, // Use email if no displayName
                toUserId: targetUser.uid || null,
                toUserEmail: targetUser.email,
                toUserName: targetUser.name || targetUser.email, // Use email if no name
                status: "pending",
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                alert('Invitation sent!');
                fetchInvitations(currentUser);
            }).catch(error => {
                console.error('Error sending invitation:', error);
                alert('Failed to send invitation.');
            });
        }

      function handleAcceptInvitation(invitationId) {
          db.collection("invitations").doc(invitationId).update({
              status: "accepted"
          }).then(() => {
              fetchInvitations(auth.currentUser); // Use auth.currentUser
          }).catch(error => {
              console.error("Error accepting invitation:", error);
              alert("Failed to accept invitation.");
          });
      }

      function handleRejectInvitation(invitationId) {
          db.collection("invitations").doc(invitationId).delete()
              .then(() => {
                  fetchInvitations(auth.currentUser); // Use auth.currentUser
              })
              .catch(error => {
                  console.error("Error rejecting invitation:", error);
                  alert("Failed to reject invitation.");
              });
      }

        let simulation = null;
        let currentPhysics = false;

        let currentUsers = [];
        let currentConnections = [];

        function createVisualization(users = [], connections = [], enablePhysics = false) {
            if (!Array.isArray(users) || !Array.isArray(connections)) {
                console.error('Invalid data received:', { users, connections });
                return;
            }

            const container = d3.select("#visualization");
            container.html("");
            if (simulation) simulation.stop();

            const width = 800;
            const height = 700;
            const centerX = width / 2;
            const centerY = height / 2;

            const svg = container.append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .style("width", "100%")
                .style("max-width", "800px")
                .style("margin", "0 auto");

            const getDisplayName = user => {
                const name = user.name || user.email;
                return name.split('@')[0]
                    .split('.')
                    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
                    .join(' ');
            };

            const nodes = users.map(user => ({
                id: user.email ? user.email.trim() : "",
                label: getDisplayName(user),
                name: user.name,
                x: centerX + (Math.random() - 0.5) * 100,
                y: centerY + (Math.random() - 0.5) * 100
            }));

            if (enablePhysics) {
                const links = connections.map(connection => {
                    const [rawSource, rawTarget] = connection.split('-');
                    const sourceId = rawSource.trim();
                    const targetId = rawTarget.trim();
                    const source = nodes.find(n => n.id === sourceId);
                    const target = nodes.find(n => n.id === targetId);
                    return { source, target };
                }).filter(l => l.source && l.target);

                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(200).strength(0.1))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("collide", d3.forceCollide(40))
                    .force("center", d3.forceCenter(centerX, centerY))
                    .alpha(1)
                    .restart();

                const linksGroup = svg.append("g").attr("class", "links");
                const nodesGroup = svg.append("g").attr("class", "nodes");
                const labelsGroup = svg.append("g").attr("class", "labels");

                const labelBackground = labelsGroup.selectAll(".label-background")
                    .data(nodes)
                    .enter().append("rect")
                    .attr("class", "label-background")
                    .attr("fill", "white")
                    .attr("opacity", 0.8)
                    .attr("rx", 4)
                    .attr("ry", 4);

                const link = linksGroup.selectAll(".link")
                    .data(links)
                    .enter().append("line")
                    .attr("class", "link")
                    .attr("stroke", "#4CAF50")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.5);

                const node = nodesGroup.selectAll(".node")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", 8)
                    .attr("fill", "#4CAF50");

                const label = labelsGroup.selectAll(".label")
                    .data(nodes)
                    .enter().append("text")
                    .attr("class", "label")
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em")
                    .attr("font-size", "14")
                    .attr("font-weight", "500")
                    .text(d => d.label);

                label.each(function(d) {
                    const bbox = this.getBBox();
                    d.bbox = bbox;
                });

                labelBackground
                    .attr("width", d => d.bbox.width + 10)
                    .attr("height", d => d.bbox.height + 6)
                    .attr("x", d => d.bbox.x - 5)
                    .attr("y", d => d.bbox.y - 3);

                simulation.on("tick", () => {
                    link.attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node.attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label.attr("x", d => d.x)
                        .attr("y", d => d.y + 20);

                    labelBackground
                        .attr("x", d => d.x - (d.bbox.width / 2) - 5)
                        .attr("y", d => d.y + 20 - (d.bbox.height / 2) - 3);
                });

            } else {
                const radius = 300;
                const nodePositions = new Map();

                nodes.forEach((node, index) => {
                    const angle = (index * 2 * Math.PI) / nodes.length;
                    nodePositions.set(node.id, {
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle),
                        angle: angle
                    });
                });

                connections.forEach(connection => {
                    const [email1, email2] = connection.split('-');
                    const pos1 = nodePositions.get(email1.trim());
                    const pos2 = nodePositions.get(email2.trim());
                    if (pos1 && pos2) {
                        svg.append("line")
                            .attr("x1", pos1.x)
                            .attr("y1", pos1.y)
                            .attr("x2", pos2.x)
                            .attr("y2", pos2.y)
                            .attr("stroke", "#4CAF50")
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.5);
                    }
                });

                nodes.forEach(node => {
                    const pos = nodePositions.get(node.id);
                    const tempText = svg.append("text")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("font-size", "14")
                        .text(node.label);

                    const bbox = tempText.node().getBBox();
                    tempText.remove();

                    svg.append("rect")
                        .attr("x", pos.x - (bbox.width / 2) - 5)
                        .attr("y", pos.y + 20 - (bbox.height / 2) - 3)
                        .attr("width", bbox.width + 10)
                        .attr("height", bbox.height + 6)
                        .attr("fill", "white")
                        .attr("opacity", 0.8)
                        .attr("rx", 4)
                        .attr("ry", 4);

                    svg.append("line")
                        .attr("x1", centerX)
                        .attr("y1", centerY)
                        .attr("x2", pos.x)
                        .attr("y2", pos.y)
                        .attr("stroke", "#4CAF50")
                        .attr("stroke-width", 1)
                        .attr("opacity", 0.2);

                    svg.append("circle")
                        .attr("cx", pos.x)
                        .attr("cy", pos.y)
                        .attr("r", 6)
                        .attr("fill", "#4CAF50");

                    svg.append("text")
                        .attr("x", pos.x)
                        .attr("y", pos.y + 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "14")
                        .attr("font-weight", "500")
                        .attr("transform", `rotate(${pos.angle * 180 / Math.PI + (pos.angle > Math.PI ? 180 : 0)}, ${pos.x}, ${pos.y})`)
                        .text(node.label);
                });
            }
        }
        // Toggle Physics
        document.getElementById('togglePhysics').addEventListener('click', () => {
            currentPhysics = !currentPhysics;
            createVisualization(currentUsers, currentConnections, currentPhysics);
        });

        // Utility function to validate data
        function isValidData(data) {
          return (
              data &&
              typeof data === 'object' &&
              data.hasOwnProperty('fromUserEmail') &&
              typeof data.fromUserEmail === 'string' &&
              data.hasOwnProperty('toUserEmail') &&
              typeof data.toUserEmail === 'string' &&
              data.hasOwnProperty('fromUserId') &&  // Check for fromUserId
              data.hasOwnProperty('toUserId')     // Check for toUserId
          );
        }

        // Generate and Copy Invitation Link
        document.getElementById("generateLinkBtn").addEventListener("click", () => {
            const user = auth.currentUser;
            if (!user) return;

            const uniqueId = Math.random().toString(36).substr(2, 9);
            const inviteLink = `${window.location.origin}/?inviteId=${uniqueId}`;

            db.collection("invitations").doc(uniqueId).set({
                fromUserId: user.uid,
                fromUserEmail: user.email,
                fromUserName: user.displayName || user.email, // Fallback to email
                toUserId: null, // Initially null, as it's a general invite
                toUserEmail: null, // Initially null
                toUserName: null,
                status: "pending",  //Consider adding status for link-based invites
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                const inviteLinkInput = document.getElementById("inviteLink");
                inviteLinkInput.value = inviteLink;
                inviteLinkInput.style.display = "block";
                document.getElementById("copyLinkBtn").style.display = "inline-block";
            });
        });

        document.getElementById("copyLinkBtn").addEventListener("click", () => {
            const inviteLinkInput = document.getElementById("inviteLink");
            inviteLinkInput.select();
            document.execCommand("copy");
            alert("Link copied to clipboard!");
        });

          // Sign Out Button
        document.getElementById('signOutBtn').addEventListener('click', () => {
            auth.signOut().then(() => {
                // Redirect to login page or perform other actions after successful sign-out
                window.location.href = "index.html"; // Assuming your login page is named "index.html"
            }).catch((error) => {
                // Handle sign-out errors
                console.error("Sign-out error:", error);
                alert("An error occurred during sign-out. Please try again.");
            });
        });


    </script>
</body>
</html>
